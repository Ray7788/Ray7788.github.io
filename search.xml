<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>强化学习2-5:MDP Reinforcement Learning Bellman</title>
      <link href="/2023/10/12/RL2-5-Bellman/"/>
      <url>/2023/10/12/RL2-5-Bellman/</url>
      
        <content type="html"><![CDATA[<h1 id="4-4-马尔科夫奖励过程的贝尔曼方程（Bellman-Equation）"><a href="#4-4-马尔科夫奖励过程的贝尔曼方程（Bellman-Equation）" class="headerlink" title="4.4 马尔科夫奖励过程的贝尔曼方程（Bellman Equation）"></a>4.4 马尔科夫奖励过程的贝尔曼方程（Bellman Equation）</h1><p>贝尔曼方程(Bellman Equation)可以用来方便的表示和计算马尔科夫奖励过程，价值函数可以分为两个部分;</p><ul><li>即时奖励$R_{t+1}$</li><li>下一状态的折扣状态价值$\gamma v(S_{t+1})$</li></ul><p>MRP的贝尔曼方程可以进行如下简单的推导： </p><script type="math/tex; mode=display">\begin{aligned} v(s) & =\mathbb E[G_t|S_t=s]{} \\ &=\mathbb E[R_{t+1}+\gamma R_{t+2} + \gamma ^2R_{t+3}+ ...|S_t=s] \\ &=\mathbb E[R_{t+1}+\gamma (R_{t+2} + \gamma R_{t+3}+ ...)|S_t=s] \\ &=\mathbb E[R_{t+1}+\gamma G_{t+1}|S_t=s] \\ &=\mathbb E[R_{t+1}+\gamma v(S_{t+1})|S_t=s] \\ \end{aligned}</script><p>贝尔曼方程的推导过程中只是简单得使用了累积回报$G<em>t$，以及状态价值函数$v</em>(s)$的基本定义。</p><p>最后即可得出当前状态价值函数$v<em>s$的值为，在当前状态$s$下，即时奖励 $R</em>{t+1}$ 与下一状态的折扣状态价值$\gamma (S_{t+1})$的期望之和。</p><p>其核心即阻碍与表示当前状态价值函数$v(s)$与下一刻状态价值函数$v(s_{t+1})$之间的递归关系。 </p><h1 id="5-马尔科夫决策过程-Markov-Decision-Process"><a href="#5-马尔科夫决策过程-Markov-Decision-Process" class="headerlink" title="5 马尔科夫决策过程(Markov Decision Process)"></a>5 马尔科夫决策过程(Markov Decision Process)</h1><h2 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h2><p>到目前为止其实我们都没有讲到强化学习，因为我们虽然对原始的马尔科夫过程（Markov Process,MP）引入了奖励<br>而引入马尔科夫奖励过程（Markov Reward Process，MRP），可是我们并没有决策的部分，强化学习本身是一个决策的问题。所以现在我们再引入一个因子，就是动作（Action）。从而将MRP问题变成了.马尔科夫决策过程（Markov Decision Processes,MDP）。此时才能算得上是强化学习。MDP是一个环境，里面的每个状态都满足马尔科夫性质（Markov Property）。</p><blockquote><p>马尔科夫决策过程(Markov DecisionProcess)定义：</p><p>一个马尔科夫决策过程(Markov DecisionProcess)，由一个五元组构成：$<S,A,P,R,\gamma>$</p><ul><li>S为有限的状态空间集，$s_i$表示时间步$i$的状态，其中$S={s_1,s_2,…s_n}$</li><li>A为动作空间集，$a_i$表示时间步$t$的动作，其中$A={a_1,a_2,…,a_n}$</li><li>$P$为状态转移矩阵，表示在当前状态$s$下执行动作$a$后，转移到另一个状态$s’$的概率分布，可以记为 $\mathbb P<em>{ss’}^a=\mathbb P[S</em>{s+1}=s’| S_t=s,A_t=a]$</li><li>R为奖励函数，表示在状态$s$下执行动作$a$后转移到另一个状态$s’$获得的奖励，  $R<em>s^a=\mathbb E[R</em>{t+1}|S_t=s,A_t=a]$</li><li>$\gamma$为折扣因子，$\gamma \in [0,1]$</li></ul></blockquote><p>这里需要注意的是，因为有了动作的加入，奖励不再只和状态相关，还和动作有关。之前的奖励是离开状态就获取的即时奖励，现在是在某个状态下采取特定动作后获取的即时奖励.</p><h2 id="5-1-策略（Policy）"><a href="#5-1-策略（Policy）" class="headerlink" title="5.1 策略（Policy）"></a>5.1 策略（Policy）</h2><p>策略是状态到动作的映射，在某个状态下采取什么样的动作，可以是确定的策略，也可以是一个随机策略(概率事件),一般用$\pi$表示。其定义如下：</p><script type="math/tex; mode=display">\pi(a|s) =P[A_t=a|S_t=s]</script><blockquote><ul><li>策略完整定义了智能体的所有行为方式。</li><li>MDP的策略只依赖于当前的状态，不依赖于历史状态。</li><li>策略是稳态的，不受时间约束。 即$A_t \sim \pi(.|S_t),\forall t\gt 0 $。</li><li>在给定一个MDP，$M=<S,A,P,R,\gamma>$以及一个策略$\pi$，那么状态序列$S_1,S_2,…$，可以表示的前面章节描述的马尔科夫过程(MP)为$<S,P^{\pi}>$。</li><li>在给定一个MDP，$M=<S,A,P,R,\gamma>$以及一个策略$\pi$，那么状态与奖励序列$S_1,R_2,S_2,R_3…，$可以表示前面章节描述的的马尔科夫奖励过程（MRP）为$<S,P^{\pi},R^{\pi},\gamma>$。</li></ul></blockquote><p>上述中的状态转移矩阵与奖励函数定义为：</p><script type="math/tex; mode=display">P_{s,s'}^{\pi} = \sum_{a \in A}\pi (a|s)P_{ss'}^a</script><script type="math/tex; mode=display">R_{s}^{\pi} = \sum_{a \in A}\pi (a|s)R_{s}^a</script><p>奖励函数可以描述为：在执行策略π时获得的奖励等于执行该状态下所有行为的概率与对应行为产生的即时奖励的乘积的和。</p><h2 id="5-2-价值函数（Value-Function）"><a href="#5-2-价值函数（Value-Function）" class="headerlink" title="5.2 价值函数（Value Function）"></a>5.2 价值函数（Value Function）</h2><p>MDP的价值函数和MRP的有一些不同，增加了与策略相关的内容。正因为有了策略，价值函数不再单纯的只和状态$s$相关了。采取不同的策略，价值函数也会不同。</p><p>因为从贝尔曼方程中我们也能看出，价值的计算和动作相关，而动作的选择就是策略。但是这里不得不提一下，这里的价值函数只是策略的价值函数，它的好坏不一定代表真正的状态的好坏，它只是根据你提供的这个策略计算出来的，提供的这个策略不一定是一个好策略,那么自然计算出来的价值不一定具有很强的参考性。</p><p>当执行到某一步时，如果需要评估当前智能体在该时间步状态的好坏程度，主要由价值函数（Value Function）来完成。由于价值函数的输入分为状态$s$和&lt;状态，价值&gt;对<code>&lt;s,a&gt;</code>，所以通常当输入状态时统称为状态值函数，输入&lt;状态，价值&gt;对$<s,a>$时统称为动作值函数，当不讨论其输入时，统称为价值函数。</p><p>一个马尔科夫决策过程的状态值函数$v_{\pi}(s)$是对未来奖励的预测，表示在状态<code>s</code>下，跟随给定的策略$\pi$会得到的奖励期望。 </p><script type="math/tex; mode=display">v_{\pi}(s) = E_{\pi}[G_t|S_t=s]</script><p>一个马尔科夫决策过程的动作值函数$q<em>{\pi} (s,a)$，表示在状态s下，执行动作a，并跟随给定的策略$\pi$会得到的奖励期望。 $$q</em>{\pi}(s,a)=E_{\pi}[G_t|S_t=s,A_t=a]$$</p><h2 id="5-3-最优值函数（Optimal-Value-Function）"><a href="#5-3-最优值函数（Optimal-Value-Function）" class="headerlink" title="5.3 最优值函数（Optimal Value Function）"></a>5.3 最优值函数（Optimal Value Function）</h2><p>我们更希望的是最优值函数，最优值函数是与策略无关的，根据最优值函数可以直接得到最优策略。</p><p>只需要沿着状态价值函数大的方向移动就行，这其实也就是强化学习中的一个流派，基于值学习的(相对于基于策略学习)。值比较大的状态就是好，比如终点前的一个状态值一般就比较大,因为下一刻就可以结束。</p><p>此处用”一般”是因为考量的是状态值，如果这个状态不仅和终点相连并且还和几个失败点相连，状态值不一定大。参考贝尔曼方程计算公式，如果我们使用另一种动作值函数，代表状态$s$下采取特定动作$a$的价值。那么我们就可以说,终点前一个状态，采取动作$a$可以直接到终点，这个$q(s,a)$一定是一个大值。这也提示了使用$q(s,a)$值一般比使用状态价值$v(s)$更好，因为考虑了动作。</p><p>最优值函数确定了马尔科夫决策过程中智能体的最优的可能表现。获得了最优值函数，也就获得了么个状态的最有价值，那么此时马尔科夫决策过程的所有变量都为已知的，接下来便能够很好的求解马尔科夫决策过程的问题。</p><h2 id="5-4-最优策略（Optimal-Policy）"><a href="#5-4-最优策略（Optimal-Policy）" class="headerlink" title="5.4 最优策略（Optimal Policy）"></a>5.4 最优策略（Optimal Policy）</h2><p>最优策略（Optimal Policy）的定义为： <script type="math/tex">\pi \ge \pi ’ \ \ \ if \ \ \ v_{\pi}(s) \ge v_{\pi'}(s),\forall s</script> 在状态$s$下，当策略$\pi$的价值函数优于任何其他策略$\pi’$的价值函数时，策略$\pi$即为状态$s$下的最优策略。关于马尔科夫决策过程的最优策略，有如下3个定理：</p><p>（1）对于任何马尔科夫决策过程问题，存在一个最优策略$\pi<em>* $，其优于（至少等于）任何其他策略，即$\pi</em>* \ge \pi$。</p><p>（2）所有最优策略下都有最优状态值函数，即$v<em>{\pi} (s) = v</em>* (s)$ </p><p>（3）所有最优策略下都有最优动作值函数，即$q<em>{\pi} (s,a) = q</em>* (s,a)$</p><p>基于上述三个定理，寻找最优策略可以通过最优状态值函数$v<em>{\pi}(s)$或者最优动作值函数$q</em>{\pi}(s,a)$来得到。也就是说如果最优值函数已知，则可以获得马尔科夫决策过程的最优策略。</p><p>因此，可以通过最大化$q^(s,a)$得到最优策略$\pi$，具体的定义如下：</p><script type="math/tex; mode=display">\pi_{}(a|s)=\begin{cases} 1,\quad if \ \ a= \max_{a \in A}\ q(s,a) \\ 0,\quad 其他 \end{cases}</script><p>上式中，$a= \max<em>{a \in A}\ q(s,a)$时，$\pi(a|s)$为1，表明如果动作值函数的最大值为最优策略所选择的动作，那么智能体已经找到最优策略$\pi$。只要最优动作值函数$q</em><em> (s,a)$已知，就可以立即获得最优策略。综上所述，最优策略$\pi$对于任何马尔科夫决策过程都会有一个对应的确定性最优策略$\pi_{</em>}(a|s)$。</p><p>到目前为止，最优策略的求解问题事实上已经转换成为了最优值函数的求解问题。如果已经求出最优值函数，那么最优策略是非常容易得到的，反之同理。通过最优策略求解问题的转换，可以将鼓励的最优策略$\pi$、最优值函数$v(s)$、最优动作值函数$q^*(s,a)$连为一体。需要注意的是，在实际工作中，也可以不求最优值函数，而使用其他方法直接求解最优策略。</p><h3 id="5-4-求解贝尔曼最优方程"><a href="#5-4-求解贝尔曼最优方程" class="headerlink" title="5.4 求解贝尔曼最优方程"></a>5.4 求解贝尔曼最优方程</h3><p>上面描述的回溯图过程中已经给出了贝尔曼最优方程的基本形式，其阐述的一个事实是：最优策略下各个状态的价值一定等于这个状态下最优动作的期望回报。我们已经知道，</p><ul><li>求解强化学习问题实际上是求解最优策略。</li><li>最优策略可以通过求解最优值函数得到。</li><li>最优值函数的求解就是优化贝尔曼方程。</li></ul><p>简而言之，强化学习的求解最后演化成了优化贝尔曼方程。贝尔曼最优方程实际上是一个方程组，每个状态对应一个方程等式。也就是说，如果有$n$个状态，那么有$n$个含有$n$个未知量的方程。如果环境的动态变化特性$p$是已知的，那么原则上可以用解非线性方程组的求方法来求解$v$方程组。类似地，我们也可以求得$q$的一组解。对于小规模的马尔科夫决策过程，可以直接求解价值函数，对于大规模的马尔科夫决策过程，通常非常难以获得解析解，必须采用迭代的方法优化贝尔曼方程。比如：</p><ul><li>Value Iteration算法</li><li>Policy Iteration算法</li><li>Q-learning算法</li><li>Sarsa算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习2:MDP Reinforcement Learning2 Markov Decision Process</title>
      <link href="/2023/08/04/RL2-Markov/"/>
      <url>/2023/08/04/RL2-Markov/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文基于 DeepMind research 领头人David Silver的<a href="https://www.deepmind.com/learning-resources/introduction-to-reinforcement-learning-with-david-silver">Intro to RL</a>教学视频和互联网上各大神的笔记统一整理，如有错误请斧正，谢谢！  </p><p>因GitHub page与自己博客主题渲染引擎问题，部分公式提供Katex和Markdown两种公式代码，以确保根据您的浏览器获得最佳阅读效果。</p><p>为了一步步引入MDP，我们将循序渐进地从马尔科夫性质（Markov Process），马尔科夫奖励过程（Markov Reward Process，MRP），再到马尔科夫决策过程（Markov Decision Processes,MDP）。最后再对MDP进行部分扩展，如有限与连续MDPs(Infinite and continuous MDPs)，部分观测MDP（Partially Observable MDPs，POMDP）以及无折扣或平均奖励MDPs(Undiscounted, average reward MDPs)。</p><h1 id="1-马尔科夫性质（Markov-Property）"><a href="#1-马尔科夫性质（Markov-Property）" class="headerlink" title="1. 马尔科夫性质（Markov Property）"></a>1. 马尔科夫性质（Markov Property）</h1><p>进一步了解马尔科夫决策过程之前，需要先了解马尔科夫性质(Markov Property)，马尔科夫性质即未来的状态只依赖于当前状态，与过去状态无关。<br>正式的定义如下：</p><blockquote><p>马尔科夫性质（Markov Property）定义：<br>在时间步 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，环境的反馈仅取决于上一时间步<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>的状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>，与时间步<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>以及<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>步之前的时间步都没有关联性。<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">[</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>t</mi></msub><mo stretchy="false">]</mo><mo>=</mo><mi>P</mi><mo stretchy="false">[</mo><msub><mi>S</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>S</mi><mi>t</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P[S_{t+1}|S_t]=P[S_{t+1}|S_1,...,S_t]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span><br><!-- 需要KateX --></p></blockquote><p>马尔科夫性，也就是无后效性。根据定义，当前状态捕捉了历史中所有相关的信息，所以知道了状态，状态是未来的充分统计。某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响，历史(history)就可以完全丢弃。也就是说，未来与过去无关。举个不恰当的例子：A股某些医疗股的变化指数。。。</p><p>然而在实际的环境中，智能体所需完成的任务不能够完全满足马尔科夫性质，即在时间步<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的反馈不一定仅仅依赖于时间步<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathnormal">t</span></span></span></span>的状态和动作。但是为了简化问题的求解过程，仍然假设该任务满足马尔科夫属性（Markov Property），并通过约束环境的状态使得问题满足马尔科夫属性。</p><h1 id="2-马尔科夫过程（Markov-Process）"><a href="#2-马尔科夫过程（Markov-Process）" class="headerlink" title="2. 马尔科夫过程（Markov Process）"></a>2. 马尔科夫过程（Markov Process）</h1><p>AKA Markov Chain. 是一个无记忆的随机过程，可有用元组<S,P>表示，其中S为有限数量的状态集，P为状态转移概率矩阵。</p><blockquote><ul><li>S为有限的状态空间集，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示时间步<code>i</code>的状态，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>s</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S=\{s_1,s_2,...s_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>为状态转移矩阵，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>s</mi><mi>n</mi></msub><mo stretchy="false">}</mo><msub><mi>P</mi><mrow><mi>s</mi><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></msub><mo>=</mo><mi>P</mi><mo stretchy="false">[</mo><msub><mi>S</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>t</mi></msub><mo>=</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S=\{s_1,s_2,...s_n\}  P_{ss&#x27;}=P[S_{s+1}=s&#x27;| S_t=s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">]</span></span></span></span></li></ul><p>以下是将给定文本中的公式转换为Markdown公式的结果：</p><ul><li>(S) 为有限的状态空间集，(s_i) 表示时间步 (i) 的状态，其中 (S={s_1, s_2, \ldots, s_n})。</li><li>(p) 为状态转移矩阵，(S={s<em>1, s_2, \ldots, s_n})  (P</em>{ss’}=P[S_{s+1}=s’| S_t=s])<br>状态与状态之间的转换过程即为马尔科夫过程。虽然我们可能不知道P的具体值到底是什么，但是通常我们假设P是存在的（转移概率存在，如果是确定的，无非就是概率为1），而且是稳定的（意思是从状态A到其他状态的转移虽然符合某个分布，但是其转移到某个状态的概率是确定的，不随时间变化的）。</li></ul></blockquote><!-- <table rules="none" align="center">    <tr>        <td>            <center>                <img src="/img/RL2-Matrix" width="60%" />                <br/>                <font color="AAAAAA">在本图中。</font>            </center>        </td>    </tr></table> --><!--  --><p><img src="./img/RL2_01.webp" alt=""></p><p>上图中，圆圈表示学生所处的状态，方格Sleep是一个终止状态，终止状态也可以理解成以100%的概率转移到自己，所以一旦进入，就停留在此。箭头表示状态之间的转移，箭头上的数字表示状态转移概率。</p><p>例如，当学生处在第一节课（Class1）时，有50%的概率会上第2节课（Class2）；同时也有50%的概率不认真听课，进入到刷facebook这个状态中。在刷facebook这个状态时，比较容易沉迷，有90%的概率在下一时刻继续浏览，有10%的概率返回到第一节课。当学生进入到第二节课（Class2）时，会有80%的概率继续参加第三节课（Class3），有20%的概率觉得课程较难而被迫下课（Sleep）。当学生处于第三节课这个状态时，有60%的概率通过考试，继而100%的结课，也有40%的概率去泡吧。泡吧之后，又分别有20%、40%、40%的概率返回值第一、二、三节课重新继续学习。</p><p>假设学生马尔科夫链从状态Class1开始，最终结束于Sleep。其间的过程根据状态转化图可以有很多种可能性，这些都称为采样片段Sample Episodes。以下四个Episodes都是可能的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C1 - C2 - C3 - Pass - Sleep</span><br><span class="line"></span><br><span class="line">C1 - FB - FB - C1 - C2 - Sleep</span><br><span class="line"></span><br><span class="line">C1 - C2 - C3 - Pub - C2 - C3 - Pass - Sleep</span><br><span class="line"></span><br><span class="line">C1 - FB - FB - C1 - C2 - C3 - Pub - C1 - FB - FB - FB - C1 - C2 - C3 - Pub - C2 - Sleep</span><br></pre></td></tr></table></figure><h2 id="2-1-马尔科夫链与Episode"><a href="#2-1-马尔科夫链与Episode" class="headerlink" title="2.1 马尔科夫链与Episode"></a>2.1 马尔科夫链与Episode</h2><p>Episode可以翻译为片段、情节、回合等，在强化学习问题中，一个Episode就是一个马尔科夫链，根据状态转移矩阵可以得到许多不同的episode，也就是多个马尔科夫链。</p><p>强化学习问题分两种：</p><ul><li>如果一个任务总能达到终态，结束任务或者开启下一轮任务，那么这个任务就被称为回合任务，也就是episode任务。例如，让一个智能体学习如何下围棋，围棋棋盘只有那么大，游戏定会终局，所以是一个回合式任务。</li><li>如果一个任务可以无限持续下去，永远不会结束，即永远在训练当中，那么这个任务就被称为连续性任务。例如，教会一辆车能够进行自动驾驶就是一个连续性任务，不要钻牛角尖说能源会耗尽，车子会磨损，我们只聚焦问题与环境本身，不涉及其他非稳定因素。</li></ul><h1 id="3-状态转移矩阵-State-Transition-Matrix"><a href="#3-状态转移矩阵-State-Transition-Matrix" class="headerlink" title="3. 状态转移矩阵(State Transition Matrix)"></a>3. 状态转移矩阵(State Transition Matrix)</h1><p>对于马尔科夫状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>以及后续的状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">s&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span>,状态转移概率可以定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mi>s</mi><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></msub><mo>=</mo><mi>P</mi><mo stretchy="false">[</mo><msub><mi>S</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><msub><mi>S</mi><mi>t</mi></msub><mo>=</mo><mi>s</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P_{ss&#x27;} = P[S_{s+1}=s&#x27;| S_t=s]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32797999999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">s</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mclose">]</span></span></span></span>状态转移矩阵是马尔科夫过程中状态之间转移的概率所组成的矩阵，因此大小是状态数n的平方。他反映了所有当前状态<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span>以及后续的状态$s’$的映射，所以他的每行概率之和必定为1。 </p><p>对于马尔科夫状态 (s) 以及后续的状态 (s’)，状态转移概率可以定义为： (P<em>{ss’} = P[S</em>{s+1}=s’| S_t=s])。状态转移矩阵是马尔科夫过程中状态之间转移的概率所组成的矩阵，因此大小是状态数 (n) 的平方。它反映了所有当前状态 (s) 以及后续的状态 (s’) 的映射，所以它的每行概率之和必定为 1。</p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">[</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mn>11</mn><mi>a</mi></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mn>12</mn><mi>a</mi></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mrow><mn>1</mn><mi>n</mi></mrow><mi>a</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mn>21</mn><mi>a</mi></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mn>22</mn><mi>a</mi></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mrow><mn>2</mn><mi>n</mi></mrow><mi>a</mi></msubsup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋱</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi><mi mathvariant="normal">⋮</mi><mpadded height="+0em" voffset="0em"><mspace mathbackground="black" width="0em" height="1.5em"></mspace></mpadded></mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mrow><mi>n</mi><mn>1</mn></mrow><mi>a</mi></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mrow><mi>n</mi><mn>2</mn></mrow><mi>a</mi></msubsup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">⋯</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msubsup><mi>P</mi><mrow><mi>n</mi><mi>n</mi></mrow><mi>a</mi></msubsup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}P_{11}^a &amp; P_{12}^a &amp; \cdots &amp; P_{1n}^a \\P_{21}^a &amp; P_{22}^a &amp; \cdots &amp; P_{2n}^a \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\P_{n1}^a &amp; P_{n2}^a &amp; \cdots &amp; P_{nn}^a \\\end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.459999999999999em;vertical-align:-2.4799999999999995em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.64em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-4.44em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span><span style="top:-2.5799999999999996em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋱</span></span></span><span style="top:-1.3800000000000006em;"><span class="pstrut" style="height:3.5em;"></span><span class="mord"><span class="minner">⋯</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.9799999999999995em;"><span style="top:-5.8275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-4.6275em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4518920000000004em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24810799999999997em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.7674999999999996em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord">⋮</span><span class="mord rule" style="border-right-width:0em;border-top-width:1.5em;bottom:0em;"></span></span></span></span><span style="top:-1.5675000000000006em;"><span class="pstrut" style="height:3.6875em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4799999999999995em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.953995em;"><span style="top:-1.3499850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.4999850000000006em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.0959850000000007em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.6919850000000003em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.712975em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.953995em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.4500349999999997em;"><span></span></span></span></span></span></span></span></span></span></span><p>Markdown版本：<br>[<br>\begin{bmatrix}<br>P<em>{11}^a &amp; P</em>{12}^a &amp; \cdots &amp; P<em>{1n}^a \<br>P</em>{21}^a &amp; P<em>{22}^a &amp; \cdots &amp; P</em>{2n}^a \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>P<em>{n1}^a &amp; P</em>{n2}^a &amp; \cdots &amp; P_{nn}^a \<br>\end{bmatrix}<br>]</p><!-- <table rules="none" align="center">    <tr>        <td>            <center>                <img src="/img/RL2-Markov/RL2-Matrix.png" width="60%" />                <br/>                <font color="AAAAAA">在本图中。</font>            </center>        </td>    </tr></table> --><!-- ![Transition Matrix](./RL2-Markov/RL2-Matrix.png) --><p><img src="./img/RL2-Matrix.png" alt=""></p><h1 id="4-马尔科夫奖励过程-Markov-Reward-Process"><a href="#4-马尔科夫奖励过程-Markov-Reward-Process" class="headerlink" title="4.马尔科夫奖励过程(Markov Reward Process)"></a>4.马尔科夫奖励过程(Markov Reward Process)</h1><p>原本的马尔科夫过程加上奖励值R之后就变成了马尔科夫奖励过程，元素由$<S,P>$变为$<S,P,R,\gamma>$。其中R就是奖励，$\gamma$ 是折扣因子。</p><blockquote><p>马尔科夫奖励过程(Markov Reward Process)定义：</p><p>一个马尔科夫奖励过程(MRP)，由一个四元组构成：$<S,P,R,\gamma>$</p><ul><li>S为有限的状态空间集，$s_i$表示时间步$i$的状态，其中$S={s_1,s_2,…s_n}$。</li><li>$P$为状态转移矩阵，$\mathbb P<em>{ss’}=\mathbb P[S</em>{s+1}=s’| S_t=s]$</li><li>R为奖励函数，$R<em>s=\mathbb E[R</em>{t+1}|S_t=s]$</li><li>$\gamma$为折扣因子，$\gamma \in [0,1]$</li></ul></blockquote><p>为了找到长期累积奖励，不仅要考虑当前时间步t的奖励，还需要考虑到未来的奖励。总奖励（Total Reward）$R$的计算公式如下：</p><script type="math/tex; mode=display">R=r_1+r_2+r_3...+r_n</script><p>根据总奖励R的计算公式可知，长期累积奖励从当前时间步$t$开始，直到最终状态的奖励$r_n$，得到未来累积奖励(Future Cumulative Reward)$R_t$。</p><script type="math/tex; mode=display">R=r_{t+1}+r_{t+2}...+r_n</script><!-- ![hi](./RL2-Markov/RL2-rewards.png) --><p><img src="./img/RL2-rewards2.png" alt=""></p><p>一般而言，环境是随机的或者未知的，这意味着下一个状态可能也是随机的。即由于所处的环境是随机的，所以无法确定下一次执行相同的动作，以及是否能够获得相同的奖励。向未来探索得越多，可能产生的分歧(不确定性)就越多。因此，在实际任务中，通常用折扣未来累积奖励（Discounted Future Cumulative Reward）$G_t$来代替未来累积奖励。</p><script type="math/tex; mode=display">G_t=R_{t+1}+\gamma R_{t+2}+...+\gamma^{n}R_n</script><p>如果考虑到无限时间的场景，更加通用的表示为（当前获得的奖励表示为$R_{t+1}$）：</p><script type="math/tex; mode=display">G_t=R_{t+1}+\gamma R_{t+2}+...=\sum_{k=0}^{\infty}\gamma ^k R_{t+k+1}</script><p>其中$\gamma$为折扣因子（Discount Factor），是介于$[0,1]$的常数。对于距离当前时间步越远的奖励，其重要性就越低。</p><ul><li>当γ=0时,状态S的值完全由其转移的期望立即奖励表示,即一点都不关心未来，可以认为该策略“目光短浅”。</li><li>当γ=1时,状态S的值由以当前状态为始态,运行至终态所得到的所有立即奖励加和的值表示,即未来与现在同等重要，看起来就像非常“有远见“。</li><li>当0&lt;γ&lt;1时,状态S的值是前两个模式的trade-off,即对未来看重的程度由γ决定。倘若想平衡当前时间的奖励与未来的奖励，可设置$\gamma$为一个较大的值，比如$\gamma = 0.9$。如果环境是恒定的，或者说环境的所有状态是已知（Model-based）,那么未来累积奖励可以提前获得并不需要进行折扣计算，这时候可以简单的将折扣因子$\gamma$设置为1。</li></ul><h2 id="4-2-回报（Return）与折扣因子-gamma"><a href="#4-2-回报（Return）与折扣因子-gamma" class="headerlink" title="4.2 回报（Return）与折扣因子$\gamma$"></a>4.2 回报（Return）与折扣因子$\gamma$</h2><p>大多数的马尔科夫奖励过程（MRP）与马尔科夫决策过程（MDP）都会使用折扣因子$\gamma$。主要基于如下几点考虑：</p><ul><li>数学上计算的便利性</li><li>避免未来进入循环马尔科夫过程带来的无限大回报</li><li>未来的不确定性</li><li>类比经济学中，眼前的利益比未来的利益更加有意义</li><li>人类的行为也更加倾向于眼前利益</li><li>退一步来说，令$\gamma$为1，也可以简单的转化成没有折扣因子的状态</li></ul><h2 id="4-3-价值函数-Value-Function"><a href="#4-3-价值函数-Value-Function" class="headerlink" title="4.3. 价值函数(Value Function)"></a>4.3. 价值函数(Value Function)</h2><p>价值函数是状态$s$的长期价值表示。它是上面说的回报的期望。</p><script type="math/tex; mode=display">v(s)= \mathbb E[G_t|S_t=s]</script><p>在概率论和统计学中，数学期望是试验中每次可能的结果的概率乘以结果值得总和。这里回报的期望，即价值函数会会随着折扣因子的变化而取不同的值，因为回报会因为$\gamma$的值而改变，期望自然也就会改变。</p><!-- ![hh](./RL2-Markov/RL2-rewards2.png) --><p><img src="./img/RL2-rewards2.png" alt=""></p><p>上图是$\gamma$为0.9时，例子中的马尔科夫奖励过程，红色的就是状态的价值。暂时可以不必纠结上面的价值是怎么算出来的。</p><p>通过价值函数的公式我们可以知道,要想求解一个状态的状态价值， 需要根据马尔科夫链把所有的可能列出来。每个可能都在终点终止，但是上面这个马尔科夫过程其实是有环的， 可能陷入无限循环的局面。</p><p>因为折扣因子还是1，所以会导致回报G无限大，期望也就无限大，状态价值V也就无限大。下一章节引入贝尔曼方程就是为了更好的求解价值函数的。</p>]]></content>
      
      
      <categories>
          
          <category> Theory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Minimax算法实现基础人机对抗博弈 (Minimax Algorithm)</title>
      <link href="/2023/07/08/Using-the-Minimax-Algorithm-to-implement-the-Basic-Human-Machine-Confrontation-Game/"/>
      <url>/2023/07/08/Using-the-Minimax-Algorithm-to-implement-the-Basic-Human-Machine-Confrontation-Game/</url>
      
        <content type="html"><![CDATA[<h1 id="Using-the-Minimax-Algorithm-to-implement-the-Basic-Human-Machine-Confrontation-Game"><a href="#Using-the-Minimax-Algorithm-to-implement-the-Basic-Human-Machine-Confrontation-Game" class="headerlink" title="Using the Minimax Algorithm to implement the Basic Human-Machine Confrontation Game"></a>Using the Minimax Algorithm to implement the Basic Human-Machine Confrontation Game</h1><h3 id="本文介绍了编写一个名为“奥赛罗”的Java程序来玩反转棋游戏。"><a href="#本文介绍了编写一个名为“奥赛罗”的Java程序来玩反转棋游戏。" class="headerlink" title="本文介绍了编写一个名为“奥赛罗”的Java程序来玩反转棋游戏。"></a>本文介绍了编写一个名为“奥赛罗”的Java程序来玩反转棋游戏。</h3><p>Reversi是在一个8 * 8的棋盘上玩的双人棋游戏♟。棋子分为黑白两色，故称“黑白棋”；因为行棋之时将对方棋子翻转，变为己方棋子，故又称“翻转棋”（Reversi）。  </p><h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><p><strong>在下面的描述中，线段的定义是形成连续直线（水平、垂直或对角线）的一系列棋盘方块。</strong></p><p>玩家放置棋子的规则是该棋子必须放置在一个空的方块上，使得有一条线段穿过所下的棋子，然后穿过一个或多个相反颜色的棋子，并以玩家自己颜色的棋子结束。<br>当存在这样一条线段时，我们说对手在该线段上的棋子被包围起来。<br>游戏规定黑棋先走。<br>当放置一个棋子时，被包围的棋子会根据以下规则改变颜色：</p><ul><li>对于每一条线段穿过所玩的棋子，然后穿过一个或多个相反颜色的棋子，并以玩家自己颜色的棋子结束，则该线段所穿过的相反颜色的棋子全部更改为玩家自己的颜色棋子。</li></ul><table rules="none" align="center">    <tr>        <td>            <center>                <img src="/img/Reversi01.png" width="60%" />                <br/>                <font color="AAAAAA">在本图中，左图显示了白方可能采取的走法，将对手的三个棋子括起来，形成右图所示的位置。</font>            </center>        </td>    </tr></table><p>当且仅当一名玩家无法移动而其对手可以移动时，该玩家就错过了一个回合。 当两个玩家都无法移动时游戏结束。（这种情况通常（但并非总是）发生，因为所有方格都已被占据。）获胜者是棋盘上自己颜色的棋子数量较多的玩家； 如果没有这样的玩家，则结果为平局。</p><hr><h3 id="类文件，配置具体介绍"><a href="#类文件，配置具体介绍" class="headerlink" title="类文件，配置具体介绍"></a>类文件，配置具体介绍</h3><h4 id="玩家端（人类）"><a href="#玩家端（人类）" class="headerlink" title="玩家端（人类）"></a>玩家端（人类）</h4><ul><li>主要的游戏逻辑是在 BoardState 中。</li><li>数字代表颜色（1表示白色；-1表示黑色，0代表没有）</li><li>getContents(int x, int y)  和  void setContents(int x, int y, int piece)    允许在棋盘方块上检索和设置。</li><li>boolean checkLegalMove(int x, int y),  它检查当前玩家是否有可能在正方形（x，y）上移动。</li><li>检索当前玩家的合法移动列表的方法是ArrayList<Move> getLegalMoves()。此方法返回当前玩家的所有合法移动。</li><li></li></ul><hr><h4 id="机器端（电脑）"><a href="#机器端（电脑）" class="headerlink" title="机器端（电脑）"></a>机器端（电脑）</h4><ul><li>计算机端（电脑）位于MoveChooser.java 中，其中的 <code>main</code> 程序创建了一个实例。</li><li>这个类所做的唯一的事情是实现静态方法 <code>chooseMove(BoardState boardState)</code> 在它的当前版本中，这个方法只是获取合法的移动，如果该列表为空，则返回null（记住我说的有时会没有合法的移动），否则返回该列表中的第一个移动。</li><li><p>在这里我们写一个更好的移动选择函数，而不是每次仅默认选择第一个。我们使用minimax with αβ-pruning 方法来优化。</p><ul><li>首先赋予棋盘每个位置相应的权重，为后续通过计算路线成本来规划最佳路线做准备。<pre><code>&gt; 这些数字反映了一个玩家在各自的方块上的价值。请注意，边缘上的正方形具有很高的值（因为这里的块很难取），而角落上的正方形具有更高的值（因为这里不能取块）。相比之下，相邻的方块有负值，因为这里的一块将允许对手移动到一个高值的方块上。然后，板位置的值可以通过将白块占据的所有方块的权重加起来，然后减去黑块占据的所有方块的权重来定义。 </code></pre></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// numbers reflect the value for a player of being on the respective square</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> positionValue[][] = &#123;   </span><br><span class="line">    &#123;<span class="number">120</span>, -<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">20</span>, -<span class="number">20</span>, <span class="number">120</span>&#125;,</span><br><span class="line">    &#123;-<span class="number">20</span>, -<span class="number">40</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">40</span>, -<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">20</span>, -<span class="number">5</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">15</span>, -<span class="number">5</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">20</span>, -<span class="number">5</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">15</span>, -<span class="number">5</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;-<span class="number">20</span>, -<span class="number">40</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">40</span>, -<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">120</span>, -<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">20</span>, -<span class="number">20</span>, <span class="number">120</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>接下来是常规初始化：返回一个包含合法移动的列表，是否有合法移动可用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Move <span class="title function_">chooseMove</span><span class="params">(BoardState boardState)</span>&#123;</span><br><span class="line">      ArrayList&lt;Move&gt; moves = boardState.getLegalMoves();</span><br><span class="line">      <span class="keyword">if</span>(moves.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">return</span> topLevel(boardState, moves);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>下面是游戏🎮的分值计算：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////  write a better move selection function ///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// board position = + weights of all those squares occupied by white pieces - weights of those squares occupied by black pieces.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">staticEvaluation</span><span class="params">(BoardState boardState)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123;</span><br><span class="line">            <span class="comment">// white</span></span><br><span class="line"><span class="keyword">if</span>(boardState.getContents(i, j)== <span class="number">1</span>)&#123;</span><br><span class="line">weight += positionValue[i][j]; </span><br><span class="line">            <span class="comment">// black</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(boardState.getContents(i,j)== -<span class="number">1</span>)&#123;</span><br><span class="line">weight -= positionValue[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> weight;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>使用MiniMax算法进行游戏博弈的静态方法。它接受一个BoardState对象作为游戏状态，一个搜索深度searchDepth，以及alpha、beta和maximizingNode作为MiniMax算法的参数，并返回一个整数值。</p><ul><li><p>首先，代码获取当前游戏状态下的合法移动，存储在move列表中。</p><ul><li><p>接下来，代码根据不同的条件进行分支处理：</p><p>如果searchDepth为0，即达到了搜索的最大深度，代码将调用staticEvaluation(boardState)方法对当前游戏状态进行静态评估，并返回评估值。<br>如果maximizingNode为真，表示当前节点为最大化节点（轮到最大化玩家走子），代码将执行Max节点的逻辑。<br>如果以上条件都不满足，表示当前节点为最小化节点（轮到最小化玩家走子），代码将执行Min节点的逻辑。</p></li></ul></li><li><p>Max节点的逻辑：</p><p>  将alpha初始化为最小整数值，表示下界。<br>  对于每个合法移动，进行以下操作：  </p><ul><li>如果alpha &gt;= beta，即上界小于等于下界，或者move列表为空，退出循环。  </li><li>创建一个boardState对象的深拷贝，用于模拟在当前移动下的新游戏状态。  </li><li>对深拷贝的boardState对象调用makeLegalMove(move.get(i).x, move.get(i).y)方法，执行当前移动。  </li><li>调用miniMax(boardState1, searchDepth-1, alpha, beta, false)方法，以递归方式搜索下一层的最小化节点，并将返回值存储在miniVal中。<br>如果miniVal大于alpha，更新alpha的值为miniVal。<br>返回alpha作为当前节点的评估值。  </li></ul></li><li><p>Min节点的逻辑：</p><p>  将beta初始化为最大整数值，表示上界。<br>  对于每个合法移动，进行以下操作：  </p><ul><li>如果alpha &gt;= beta，即上界小于等于下界，或者move列表为空，退出循环。  </li><li>创建一个boardState对象的深拷贝，用于模拟在当前移动下的新游戏状态。  </li><li>对深拷贝的boardState对象调用makeLegalMove(move.get(i).x, move.get(i).y)方法，执行当前移动。  </li><li>调用miniMax(boardState1, searchDepth-1, alpha, beta, true)方法，以递归方式搜索下一层的最大化节点，并将返回值存储在maxVal中。<br>如果maxVal小于beta，更新beta的值为maxVal。<br>返回beta作为当前节点的评估值。  </li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// αβ-pruning DFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">miniMax</span><span class="params">(BoardState boardState, <span class="type">int</span> searchDepth, <span class="type">int</span> alpha, <span class="type">int</span> beta, Boolean maxmizingNode)</span>&#123;</span><br><span class="line">ArrayList&lt;Move&gt; move = boardState.getLegalMoves();</span><br><span class="line"><span class="keyword">if</span>(searchDept == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> staticEvaluation(boardState);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxmizingNode)&#123;</span><br><span class="line">        alpha = Integer.MIN_VALUE;  <span class="comment">// lower bound</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;move.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(alpha &gt;= beta || move.isEmpty())&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// a fresh copy of boardState</span></span><br><span class="line"><span class="type">BoardState</span> <span class="variable">boardState1</span> <span class="operator">=</span> boardState.deepCopy();</span><br><span class="line">boardState1.makeLegalMove(move.get(i).x, move.get(i).y);</span><br><span class="line"><span class="type">int</span> <span class="variable">miniVal</span> <span class="operator">=</span> miniMax(boardState1, searchDepth-<span class="number">1</span>, alpha, beta, <span class="literal">false</span>);<span class="comment">// next is minimizing</span></span><br><span class="line"><span class="keyword">if</span>(alpha &lt; miniVal)&#123;<span class="comment">// update alpha</span></span><br><span class="line">alpha = miniVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> alpha;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">beta = Integer.MAX_VALUE;   <span class="comment">// upper bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;move.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(alpha &gt;= beta||move.isEmpty())&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// a fresh copy of boardState</span></span><br><span class="line"><span class="type">BoardState</span> <span class="variable">boardState1</span> <span class="operator">=</span> boardState.deepCopy();</span><br><span class="line">boardState1.makeLegalMove(move.get(i).x, move.get(i).y);</span><br><span class="line"><span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> miniMax(boardState1, searchDepth-<span class="number">1</span>, alpha, beta, <span class="literal">true</span>);<span class="comment">// next is maxmizing</span></span><br><span class="line"><span class="keyword">if</span>(maxVal &lt; beta)&#123;<span class="comment">// update beta</span></span><br><span class="line">beta = maxVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶层调用与后续调用略有不同，因为您必须选择产生最佳子节点的着法（从计算机玩家的角度来看），而不是简单地评估子节点的值。 重要的是，当且仅当没有可用的移动时，程序才返回空移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// The top-level call</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Move <span class="title function_">topLevel</span><span class="params">(BoardState bs, ArrayList&lt;Move&gt; move)</span>&#123;</span><br><span class="line"><span class="comment">// searchDepth 设置成8保证运行速度和智能程度的权衡</span></span><br><span class="line">   <span class="type">int</span> searchDepth= Othello.searchDepth;</span><br><span class="line">   <span class="type">int</span> <span class="variable">valueIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.MIN_VALUE;<span class="comment">// negative infinity</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">// positive infinity</span></span><br><span class="line">   <span class="type">Move</span> <span class="variable">bestChoice</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// set when there are no moves available as the default value </span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;move.size(); i++)&#123;</span><br><span class="line">   <span class="type">BoardState</span> <span class="variable">temp</span> <span class="operator">=</span> bs.deepCopy();</span><br><span class="line">   temp.makeLegalMove(move.get(i).x, move.get(i).y);</span><br><span class="line">   <span class="type">int</span> <span class="variable">minimax</span> <span class="operator">=</span> miniMax(temp, searchDepth-<span class="number">1</span>, a, b, <span class="literal">false</span>);<span class="comment">// at the beginning set to minimizing node</span></span><br><span class="line">   <span class="keyword">if</span>(a&lt;minimax)&#123;</span><br><span class="line">   a=minimax;</span><br><span class="line">   valueIndex = i;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   bestChoice = move.get(valueIndex);</span><br><span class="line">   <span class="keyword">return</span> bestChoice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="游戏运行注意事项"><a href="#游戏运行注意事项" class="headerlink" title="游戏运行注意事项"></a>游戏运行注意事项</h2><ul><li>当且仅当一个玩家不能移动，但TA的对手可以移动时，TA才算错过这个回合。 </li><li>人类玩家（总是黑色）与计算机（总是白色）颜色保持不变。   </li><li>点击不合法动作的方块会产生警告声；如果轮到玩家（人类）下棋，但玩家没有合法的移动 ，那么玩家必须点击棋盘上的任何地方以允许游戏传递到电脑；  </li><li>如果玩家想玩另一个游戏，需要关闭窗口，重新运行程序。  </li><li>最好在电脑“思考”时不要点击以进行干扰。  </li><li>最后，作为一种特别的刺激，如果游戏以电脑的移动而结束，那么玩家必须点击棋盘才能看到结果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过函数式编程和四叉树模型解决双值图像的色彩处理问题 Using Haskell to solve QuadTree problems</title>
      <link href="/2023/06/25/Use-Haskell-solve-QuadTree-problems/"/>
      <url>/2023/06/25/Use-Haskell-solve-QuadTree-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="通过函数式编程和四叉树模型解决双值图像的色彩处理问题"><a href="#通过函数式编程和四叉树模型解决双值图像的色彩处理问题" class="headerlink" title="通过函数式编程和四叉树模型解决双值图像的色彩处理问题"></a>通过函数式编程和四叉树模型解决双值图像的色彩处理问题</h1><!--  --><h2 id="二叉树的介绍"><a href="#二叉树的介绍" class="headerlink" title="二叉树的介绍"></a>二叉树的介绍</h2><p>四叉树（Quad Tree）是一种树状数据结构，可用于表示图像。在每一个四叉树会有四个子区块。四叉树常应用于二维空间资料的分析与分类。 它将资料区分成为四个象限。资料范围可以是方形或矩形或其他任意形状。这种数据结构是由 拉斐尔·芬科尔(Raphael Finkel) 与 J. L. Bentley 在1974年发展出来。 类似的资料分割方法也称为 Q-tree。</p><p>本博文中使用函数式编程(Functional Programming)的Haskell作为编程语言，通过递归思想，实现对由四叉树表示的的双值图像的色彩检测。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>假设我们需要存储一张像素大小为 2^{𝑛} ∗ 2^{𝑛} 的正方形双值（黑白双色）图像，一般使用一个bit（0或1）来存储一个像素值，需要2^{𝑛} ∗ 2^{𝑛} bit的存储空间。但如果图像中有大面积的单色区域，这种存储方式可能会造成浪费。<br><!-- ![原图像](/img/Haskell01.png)![右下角浪费](/img/Haskell02.png)![左上角也浪费](/img/Haskell03.png) --></p><table rules="none" align="center">    <tr>        <td>            <center>                <img src="/img/Haskell01.png" width="60%" />                <br/>                <font color="AAAAAA">原图像</font>            </center>        </td>        <td>            <center>                <img src="/img/Haskell02.png" width="60%" />                <br/>                <font color="AAAAAA">右下角浪费</font>            </center>        </td>        <td>            <center>                <img src="/img/Haskell03.png" width="60%" />                <br/>                <font color="AAAAAA">左上角的四分格中也浪费</font>            </center>        </td>    </tr></table><h2 id="解决方案大致思想"><a href="#解决方案大致思想" class="headerlink" title="解决方案大致思想"></a>解决方案大致思想</h2><p>在这种情况下，一个简单的优化方式是将图像分为四个大小为 2^{𝑛-1} ∗ 2^{𝑛-1} 的子图像，我们将其称为“象限”（quadrants）。 如果某子图像是纯色图像，我们可以用单一颜色信息（黑色或白色）来表示。但如果它包含不同的颜色（黑色和白色混掺），我们可以再次细分，并继续递归，直到我们得到只有一种颜色的子图像。（此方案理论上可行：如果我们不断递归直至子图像缩小到原始像素的比例，问题一定能解决）。 我们将最终数据结构中的这些单一颜色子图像称为“单元”（Cell）。现实中，我们还要考虑图像实际大小，色彩标准，像素维度等多重复杂因素，在此我们忽略。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先定义几种Algebraic Data Type，也就是用关键词data来定义的代数数据类型：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 初始化颜色（黑与白） initialise colors&#x27; data type </span><br><span class="line">data Color = Black | White deriving (Eq, Show)</span><br></pre></td></tr></table></figure></p><p>这里把子图像定义为四叉树，纯色图像（Cell）和混色图像（Grid）都是子图像的子集，其中混色图像可以继续细分，直至变成纯色图像<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 实现四叉树（遵循数学中象限的定义方式：右上角为第一象限，逆时针递进，右下角为第四象限） implement QuadTree (the order of quadrant follows mathematical coordinate system)</span><br><span class="line">data QuadTree = Cell Color Int | Grid QuadTree QuadTree QuadTree QuadTree deriving (Eq, Show)</span><br></pre></td></tr></table></figure></p><p>一个函数 allBlack，它接受一个整数 n 并返回一个全黑的单个细胞的表示。 参数 n 代表图像“大小”，但由于任何尺寸的全黑图像看起来都相同，因此可以忽略此参数！ 但是我没有忽略！！！（后续有用…）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- returns a Black or White cell of a specified size</span><br><span class="line">allBlack :: Int -&gt; QuadTree</span><br><span class="line">allBlack size = Cell Black size</span><br></pre></td></tr></table></figure></p><p>一个函数 allWhite，它接受一个整数 n 并返回一个全白的单个细胞的表示。 参数 n 代表图像“大小”，同上<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allWhite :: Int -&gt; QuadTree</span><br><span class="line">allWhite size = Cell White size</span><br></pre></td></tr></table></figure><br>一个顺时针函数，它采用四个四叉树并返回四叉树，其四个子树是给定输入，按顺时针顺序排列。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- The first quadrant is top-right!</span><br><span class="line">clockwise :: QuadTree -&gt; QuadTree -&gt; QuadTree -&gt; QuadTree -&gt; QuadTree</span><br><span class="line">clockwise a b c d = Grid a b c d</span><br></pre></td></tr></table></figure><br>一个逆时针函数，它采用四个四叉树并返回四叉树，其四个子树是给定输入，按逆时针顺序排列。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anticlockwise :: QuadTree -&gt; QuadTree -&gt; QuadTree -&gt; QuadTree -&gt; QuadTree</span><br><span class="line">anticlockwise a b c d = Grid a d c b</span><br></pre></td></tr></table></figure><br>顺时针排序是指在a b c d顺时针方向的四叉树中，子树b位于a顺时针移动到达的象限内，c位于b顺时针移动到达的象限内，d位于c顺时针移动到达的象限内，a位于从d顺时针移动到达的象限内。反之亦然。</p><h2 id="重头戏"><a href="#重头戏" class="headerlink" title="重头戏"></a>重头戏</h2><p>接下来我们要进行图像处理，定义一个函数：reverse，它将四叉树作为输入并返回一个新的四叉树作为输出。 此函数不应该改变quadtree的结构，但应该改变里面表示黑白颜色的数据内容。<br>改变规则如下：<br><strong>当且仅当超过一半的邻边或部分边（这里统称为“邻居”）的单元颜色与此单元自身颜色不一致时，反转此单元的颜色（假设该单元格原先为黑色的话，现在变为白色）。</strong><br>例如，如果一个单元在输入q中是黑色的，那么它在输出模糊q中应该是白色的，当且仅当在q中它的邻居中白色的单元多于黑色的单元。<br>此处注意，宏观来看一个完整图像的边界处的单元通常具有较少的邻居。<br><img src="/img/Haskell04.png" alt="效果1"><br><img src="/img/Haskell05.png" alt="效果2"></p><h1 id="以下思路从宏观到微观依次介绍，目的是为了增强思维连续性，便于读者理解"><a href="#以下思路从宏观到微观依次介绍，目的是为了增强思维连续性，便于读者理解" class="headerlink" title="以下思路从宏观到微观依次介绍，目的是为了增强思维连续性，便于读者理解"></a>以下思路从<strong>宏观</strong>到<strong>微观</strong>依次介绍，目的是为了增强思维连续性，便于读者理解</h1><h2 id="思路介绍："><a href="#思路介绍：" class="headerlink" title="思路介绍："></a>思路介绍：</h2><p>完成这个任务有几点要考虑：<br>1 必须确保图像中的每一个单元都遍历到，才能完全输出最终反转后的图像，不能有遗漏，进一步来讲需要知道哪些单元已经遍历过了，哪些还没到访过。<br>2 遍历的出发点选在哪？何时结束遍历？<br>3 遍历的路线是怎样的？</p><p>出发点设在整个图像的中心，中心也就是整个图像长度、宽度的各二分之一处（也就是中点，一半的意思），这样就构成了一个坐标系，由此开始递归遍历。<br>以下是整个程序的start point：启动整个程序，该函数输入一个四叉树，输出处理后的二叉树<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- Original Engine of whole programme</span><br><span class="line">-- use reverseMini to implement the tree</span><br><span class="line">reverse :: QuadTree -&gt; QuadTree</span><br><span class="line">reverse fullTree = reverseMini fullTree (fullTree, fullSize) (fullSize / 2, fullSize / 2, fullSize)</span><br><span class="line">  where fullSize = getWholeSize fullTree</span><br></pre></td></tr></table></figure></p><p>接下来接棒给另一个函数：reverseMini，该函数有好多个输入参数，依次是：<br>当前所在的四叉树，表示完整图像的四叉树，完成图像四叉树的大小，遍历过程中目前所在的点的坐标（x和y），当前所在四叉树的大小。<br>输出的四叉树就是返回给reverse的最终答案，以下是细节：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- According to neighbor&#x27;s weight to decide if it should reverse the color</span><br><span class="line">-- Current QuadTree -&gt; (initial QuadTree, initial QuadTree size) -&gt; (Current x, y, Current QuadTree size) -&gt; output</span><br><span class="line">reverseMini :: QuadTree -&gt; (QuadTree, Double) -&gt; (Double, Double, Double) -&gt; QuadTree</span><br><span class="line">-- for Cell</span><br><span class="line">reverseMini (Cell ce cellSize) (fullTree, treeSize) (x_now, y_now, _)</span><br><span class="line">  --  more than half of its neighbours have the opposite colour, reverse its colour</span><br><span class="line">  | ce == Black &amp;&amp; (neighborWeight &gt; 0) = Cell White cellSize</span><br><span class="line">  | ce == White &amp;&amp; (neighborWeight &lt; 0) = Cell Black cellSize</span><br><span class="line">  | otherwise = Cell ce cellSize</span><br><span class="line">  where</span><br><span class="line">    neighborWeight = getNeighbourWeight (fullTree, treeSize) (x_now, y_now, fromIntegral cellSize)</span><br><span class="line">-- for Grid, contiinue recursion</span><br><span class="line">reverseMini (Grid a b c d) (fullTree, treeSize) (x_now, y_now, fullSize) =</span><br><span class="line">  clockwise</span><br><span class="line">    (reverseMini a (fullTree, treeSize) (x_now + offset, y_now - offset, fullSize / 2))</span><br><span class="line">    (reverseMini b (fullTree, treeSize) (x_now - offset, y_now - offset, fullSize / 2))</span><br><span class="line">    (reverseMini c (fullTree, treeSize) (x_now - offset, y_now + offset, fullSize / 2))</span><br><span class="line">    (reverseMini d (fullTree, treeSize) (x_now + offset, y_now + offset, fullSize / 2))</span><br><span class="line">  where</span><br><span class="line">    offset = fullSize / 4</span><br></pre></td></tr></table></figure><br>因为输入的四叉树可能是Grid也可能是Cell，在此分类讨论：</p><ul><li>若输入的是Cell，那么直接判断当前颜色是否与权重匹配，匹配则Cell颜色保持不变，若不匹配则颜色反转。“匹配”的含义后面会讲。</li><li>若输入的是Grid，则进一步递归当前四叉树的四个子图像a,b,c,d，同时自身坐标将会发生改变，迁移到下一个子图像的中心，用当前所在四叉树的大小折半来表示子图像的大小（四个子图像大小相等）。 </li></ul><p>首先讲一下Cell部分的设计，这里设计了一个方法来判断是否有超过一半的邻居与自身颜色不同，此方法把黑色赋权为整数-1，白色赋权为+1。然后通过计算邻居的权重之和的正负来决定是否与之匹配。<br>在这里把<strong>自身颜色为白色且权重和为正数，或者自身颜色为黑色且权重和为负数</strong>都称作与之相匹配。</p><p>接下来介绍如何通过函数getNeighbourWeight来计算邻居的权重之和。<br>下面依次介绍输入参数：<br>表示完整图像的四叉树（原图像），完整图像四叉树的大小，邻居单元的x坐标和y坐标，邻居单元的规格；<br>输出的是当前邻居的权重之和。<br>这里因为递归路线的性质需要逆向探测，所以getNeighbour方向和border方向相反，也是最巧妙的地方<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- get neighbors weight and sum the total weight of a cell&#x27;s all neighbors</span><br><span class="line">-- (initial QuadTree, initial QuadTree size) -&gt; (Neighbor Cell&#x27;s X coordinate, Cell&#x27;s Y coordinate, Cell&#x27;s size) -&gt; output</span><br><span class="line">getNeighbourWeight :: (QuadTree, Double) -&gt; (Double, Double, Double) -&gt; Int</span><br><span class="line">getNeighbourWeight (fullTree, treeSize) (x_cell, y_cell, cellSize) =</span><br><span class="line">      border (getNeighbour &quot;up&quot; (fullTree, treeSize) (x_cell, y_cell, cellSize)) &quot;down&quot;</span><br><span class="line">    + border (getNeighbour &quot;down&quot; (fullTree, treeSize) (x_cell, y_cell, cellSize)) &quot;up&quot;</span><br><span class="line">    + border (getNeighbour &quot;left&quot; (fullTree, treeSize) (x_cell, y_cell, cellSize)) &quot;right&quot;</span><br><span class="line">    + border (getNeighbour &quot;right&quot; (fullTree, treeSize) (x_cell, y_cell, cellSize)) &quot;left&quot;</span><br></pre></td></tr></table></figure></p><p> 此函数还需借鉴另外两个函数：getNeighbour和border。<br> 先介绍border函数，其输入参数为：<br> 当下需要遍历的四叉树（也可以不输入，此情况输出值为0），探测方向，<br> 输出的是根据单个Cell颜色得出的权重<br> border是“落实到基层”的函数，承担了真正根据Cell颜色赋予其权重的任务：白色+1，黑色-1，如果不是最小Cell（是Grid）就继续上下左右递归直到找到相应的Cell。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- detect one specified border of a certain Gird/Cell and sum its all cells values(weights) according to colors</span><br><span class="line">-- a Quadtree (or Nothing) -&gt; one of the four inner-borders -&gt;</span><br><span class="line">border :: Maybe QuadTree -&gt; String -&gt; Int</span><br><span class="line">-- invalid</span><br><span class="line">border Nothing _ = 0</span><br><span class="line">-- calculate the weight of the Cell</span><br><span class="line">border (Just (Cell ce _)) _</span><br><span class="line">  | ce == White = 1 -- White cells are worth +1</span><br><span class="line">  | ce == Black = -1 -- black cells are worth -1</span><br><span class="line">--  continue to implement recursion for Grid if cell is not arrived</span><br><span class="line">border (Just (Grid a b c d)) direction</span><br><span class="line">  | direction == &quot;up&quot; = border (Just a) &quot;up&quot; + border (Just b) &quot;up&quot;</span><br><span class="line">  | direction == &quot;left&quot; = border (Just b) &quot;left&quot; + border (Just c) &quot;left&quot;</span><br><span class="line">  | direction == &quot;down&quot; = border (Just c) &quot;down&quot; + border (Just d) &quot;down&quot;</span><br><span class="line">  | direction == &quot;right&quot; = border (Just a) &quot;right&quot; + border (Just d) &quot;right&quot;</span><br></pre></td></tr></table></figure></p><p>接下来说getNeighbour，由于该函数大量调用了getGrid，因此我们需要先了解getGrid函数。<br>getGrid函数作为getNeighbour的辅助函数，是程序中最复杂的一个函数，它根据getNeighbour提供的坐标变化来进一步遍历。<br>输入参数介绍：<br>四叉树，四叉树的大小（起初是完整图像，后续是便利目标的子图像），当前所在点的X，Y坐标，当前所处四叉树的大小，目标四叉树（即将要遍历的）的中点坐标以及大小</p><p>该函数有几点功能：<br>检测当前所处Grid是否为边界Grid，若遇到边界则停止遍历，否则决定下一步遍历的移动方向。<br>这里的边界线探测还是用坐标的数值来推理得出，把最小的cell大小假设成1，判断过程可以理解为尝试性地迈出0.5步，如果迈出后的坐标大于临界点（即完整图像边框线）时，则停止移动。<br>若还可以继续移动，则需要给出下一个到访的cell的中心坐标。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- helper function for getNeigbor: according to inputed coordinates and inputed size returns the Grid and also detect the boundary.</span><br><span class="line">-- Quadtree -&gt; its size -&gt; (current X coordinate, Y coordinate, size) -&gt; (target&#x27;s X coordinate, Y coordinate, size) -&gt;</span><br><span class="line">getGrid :: QuadTree -&gt; Double -&gt; (Double, Double, Double) -&gt; (Double, Double, Double) -&gt; Maybe QuadTree</span><br><span class="line">getGrid (Cell ce cellSize) _ _ _ = Just (Cell ce cellSize)</span><br><span class="line">getGrid (Grid a b c d) treeSize (x_now, y_now, sizeNow) (grid_x, grid_y, grid_size)</span><br><span class="line">  -- detect boundary</span><br><span class="line">  -- if it is already near the border, stop moving!</span><br><span class="line">  | grid_x &lt; 0.0 || grid_x &gt; (treeSize - 0.5) || grid_y &lt; 0.0 || grid_y &gt; (treeSize - 0.5) = Nothing</span><br><span class="line">  | sizeNow == grid_size = Just (Grid a b c d)</span><br><span class="line">  | x_now &gt; grid_x &amp;&amp; y_now &gt; grid_y = getGrid b treeSize (x_now - offset, y_now - offset, sizeNow / 2) (grid_x, grid_y, grid_size)</span><br><span class="line">  | x_now &lt; grid_x &amp;&amp; y_now &gt; grid_y = getGrid a treeSize (x_now + offset, y_now - offset, sizeNow / 2) (grid_x, grid_y, grid_size)</span><br><span class="line">  | x_now &gt; grid_x &amp;&amp; y_now &lt; grid_y = getGrid c treeSize (x_now - offset, y_now + offset, sizeNow / 2) (grid_x, grid_y, grid_size)</span><br><span class="line">  | x_now &lt; grid_x &amp;&amp; y_now &lt; grid_y = getGrid d treeSize (x_now + offset, y_now + offset, sizeNow / 2) (grid_x, grid_y, grid_size)</span><br><span class="line">  -- offset means how far the coordinate system should move</span><br><span class="line">  where</span><br><span class="line">    offset = sizeNow / 4</span><br></pre></td></tr></table></figure></p><p>最后我们介绍一下getNeighbor，输入参数为：<br>移动方向（进一步传导给getGrid），表示完整图像的四叉树，完成图像四叉树的大小，目标点的X，Y坐标和大小。<br>其主要作用是如何递归地调用getGrid，巧妙决定移动方向<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--  returns the Quadtree representing one of his four direct neighbors (top, bottom, left, right)</span><br><span class="line">-- direction -&gt; (initial QuadTree, initial QuadTree size) -&gt; (Cell&#x27;s X coordinate, Cell&#x27;s Y coordinate, Cell&#x27;s size)</span><br><span class="line">getNeighbor :: String -&gt; (QuadTree, Double) -&gt; (Double, Double, Double) -&gt; Maybe QuadTree</span><br><span class="line">getNeighbor direction (fullTree, treeSize) (x_cell, y_cell, cellSize)</span><br><span class="line">  | direction == &quot;top&quot; = getGrid fullTree treeSize (tree_center, tree_center, treeSize) (x_cell, y_cell - cellSize, cellSize) -- top</span><br><span class="line">  | direction == &quot;bottom&quot; = getGrid fullTree treeSize (tree_center, tree_center, treeSize) (x_cell, y_cell + cellSize, cellSize) -- bottom</span><br><span class="line">  | direction == &quot;left&quot; = getGrid fullTree treeSize (tree_center, tree_center, treeSize) (x_cell - cellSize, y_cell, cellSize) -- left</span><br><span class="line">  | direction == &quot;right&quot; = getGrid fullTree treeSize (tree_center, tree_center, treeSize) (x_cell + cellSize, y_cell, cellSize) -- right</span><br><span class="line">  where</span><br><span class="line">    tree_center = treeSize / 2</span><br></pre></td></tr></table></figure></p><p>下面补充两个辅助函数，第一个用来计算某个四叉树的大小，第二个用来作为颜色的中间转换函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- output the size of a QuadTree by calculating the length of one side (eg. top)</span><br><span class="line">getTreeSize :: QuadTree -&gt; Double</span><br><span class="line">getTreeSize (Cell ce size) = fromIntegral size</span><br><span class="line">getTreeSize (Grid a b c d) = getTreeSize a + getTreeSize b</span><br><span class="line"></span><br><span class="line">-- detect one specified side of a certain Gird/Cell and sum its all cells values according to colors</span><br><span class="line">-- a Quadtree (or Nothing) -&gt; one of the four inside-borders -&gt;</span><br><span class="line">side :: Maybe QuadTree -&gt; String -&gt; Int</span><br><span class="line">-- invalid</span><br><span class="line">side Nothing _ = 0</span><br><span class="line">-- calculate the weight of the Cell</span><br><span class="line">side (Just (Cell ce _)) _</span><br><span class="line">  | ce == White = 1 -- White cells are worth +1</span><br><span class="line">  | ce == Black = -1 -- black cells are worth -1</span><br><span class="line">--  continue to implement recursion for Grid if cell is not arrived</span><br><span class="line">side (Just (Grid a b c d)) direction</span><br><span class="line">  | direction == &quot;top&quot; = side (Just a) &quot;top&quot; + (side (Just b) &quot;top&quot;)</span><br><span class="line">  | direction == &quot;bottom&quot; = side (Just c) &quot;bottom&quot; + (side (Just d) &quot;bottom&quot;)</span><br><span class="line">  | direction == &quot;left&quot; = side (Just b) &quot;left&quot; + (side (Just c) &quot;left&quot;)</span><br><span class="line">  | direction == &quot;right&quot; = side (Just a) &quot;right&quot; + (side (Just d) &quot;right&quot;)</span><br></pre></td></tr></table></figure><p>至此，完整的代码已全部展现。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
            <tag> Functional Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/25/hello-world/"/>
      <url>/2023/02/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
