<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>强化学习2:MDP Reinforcement Learning2 Markov Decision Process</title>
      <link href="/2023/08/02/RL2-Markov/"/>
      <url>/2023/08/02/RL2-Markov/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文基于 DeepMind research 领头人David Silver的<a href="https://www.deepmind.com/learning-resources/introduction-to-reinforcement-learning-with-david-silver">Intro to RL</a>教学视频和互联网上各大神的笔记统一整理，如有错误请斧正，谢谢！  </p><p>为了一步步引入MDP，我们将循序渐进地从马尔科夫性质（Markov Process），马尔科夫奖励过程（Markov Reward Process，MRP），再到马尔科夫决策过程（Markov Decision Processes,MDP）。最后再对MDP进行部分扩展，如有限与连续MDPs(Infinite and continuous MDPs)，部分观测MDP（Partially Observable MDPs，POMDP）以及无折扣或平均奖励MDPs(Undiscounted, average reward MDPs)。</p><h2 id="1-马尔科夫性质（Markov-Property）"><a href="#1-马尔科夫性质（Markov-Property）" class="headerlink" title="1. 马尔科夫性质（Markov Property）"></a>1. 马尔科夫性质（Markov Property）</h2><p>进一步了解马尔科夫决策过程之前，需要先了解马尔科夫性质(Markov Property)，马尔科夫性质即未来的状态只依赖于当前状态，与过去状态无关。<br>正式的定义如下：</p><blockquote><p>马尔科夫性质（Markov Property）定义：<br>在时间步 $t + 1$ 时，环境的反馈仅取决于上一时间步$t$的状态$s$和动作$a$，与时间步$t-1$以及$t-1$步之前的时间步都没有关联性$2x -5y &#x3D; 8$。</p></blockquote><p>马尔科夫性，也就是无后效性。根据定义，当前状态捕捉了历史中所有相关的信息，所以知道了状态，状态是未来的充分统计。<br>某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响。历史(history)就可以完全丢弃。也就是说，未来与过去无关。举个不恰当的例子hhh，小米8的外观设计和前代的小米6完全没有关系。。。</p><p>然而在实际的环境中，智能体所需完成的任务不能够完全满足马尔科夫性质，即在时间步$t+1$的反馈不一定仅仅依赖于时间步$t$的状态和动作。但是为了简化问题的求解过程，仍然假设该任务满足马尔科夫属性（Markov Property），并通过约束环境的状态使得问题满足马尔科夫属性。</p><h2 id="2-马尔科夫过程（Markov-Process）"><a href="#2-马尔科夫过程（Markov-Process）" class="headerlink" title="2. 马尔科夫过程（Markov Process）"></a>2. 马尔科夫过程（Markov Process）</h2><p>AKA Markov Chain. 是一个无记忆的随机过程，可有用元组&lt;S,P&gt;表示，其中S为有限数量的状态集，P为状态转移概率矩阵。</p><p>状态与状态之间的转换过程即为马尔科夫过程。虽然我们可能不知道P的具体值到底是什么，但是通常我们假设P是存在的（转移概率存在，如果是确定的，无非就是概率为1），而且是稳定的（意思是从状态A到其他状态的转移虽然符合某个分布，但是其转移到某个状态的概率是确定的，不随时间变化的）。</p><h2 id="3-状态转移矩阵-State-Transition-Matrix"><a href="#3-状态转移矩阵-State-Transition-Matrix" class="headerlink" title="3. 状态转移矩阵(State Transition Matrix)"></a>3. 状态转移矩阵(State Transition Matrix)</h2><p>对于马尔科夫状态$s$以及后续的状态$s’$,状态转移概率可以定义为： $$ \mathbb P_{ss’}&#x3D;\mathbb P[S_{s+1}&#x3D;s’| S_t&#x3D;s] $$ 状态转移矩阵是马尔科夫过程中状态之间转移的概率所组成的矩阵，因此大小是状态数n的平方。他反映了所有当前状态$s$以及后续的状态$s’$的映射，所以他的每行概率之和必定为1。 $$ \mathbb P&#x3D; \left|\begin{matrix}P_{11} &amp; …&amp;P_{1n}\. &amp; &amp;.\P_{n1} &amp;… &amp;P_{nn}\end{matrix}\right| $$</p><p>$$<br>\sqrt{x^2 + y^2}<br>$$</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Reinforcement Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Minimax算法实现基础人机对抗博弈 (Minimax Algorithm)</title>
      <link href="/2023/07/07/Using-the-Minimax-Algorithm-to-implement-the-Basic-Human-Machine-Confrontation-Game/"/>
      <url>/2023/07/07/Using-the-Minimax-Algorithm-to-implement-the-Basic-Human-Machine-Confrontation-Game/</url>
      
        <content type="html"><![CDATA[<h1 id="Using-the-Minimax-Algorithm-to-implement-the-Basic-Human-Machine-Confrontation-Game"><a href="#Using-the-Minimax-Algorithm-to-implement-the-Basic-Human-Machine-Confrontation-Game" class="headerlink" title="Using the Minimax Algorithm to implement the Basic Human-Machine Confrontation Game"></a>Using the Minimax Algorithm to implement the Basic Human-Machine Confrontation Game</h1><h3 id="本文介绍了编写一个名为“奥赛罗”的Java程序来玩反转棋游戏。"><a href="#本文介绍了编写一个名为“奥赛罗”的Java程序来玩反转棋游戏。" class="headerlink" title="本文介绍了编写一个名为“奥赛罗”的Java程序来玩反转棋游戏。"></a>本文介绍了编写一个名为“奥赛罗”的Java程序来玩反转棋游戏。</h3><p>Reversi是在一个8 * 8的棋盘上玩的双人棋游戏♟。棋子分为黑白两色，故称“黑白棋”；因为行棋之时将对方棋子翻转，变为己方棋子，故又称“翻转棋”（Reversi）。  </p><h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><p><strong>在下面的描述中，线段的定义是形成连续直线（水平、垂直或对角线）的一系列棋盘方块。</strong></p><p>玩家放置棋子的规则是该棋子必须放置在一个空的方块上，使得有一条线段穿过所下的棋子，然后穿过一个或多个相反颜色的棋子，并以玩家自己颜色的棋子结束。<br>当存在这样一条线段时，我们说对手在该线段上的棋子被包围起来。<br>游戏规定黑棋先走。<br>当放置一个棋子时，被包围的棋子会根据以下规则改变颜色：</p><ul><li>对于每一条线段穿过所玩的棋子，然后穿过一个或多个相反颜色的棋子，并以玩家自己颜色的棋子结束，则该线段所穿过的相反颜色的棋子全部更改为玩家自己的颜色棋子。</li></ul><table rules="none" align="center">    <tr>        <td>            <center>                <img src="/img/Reversi01.png" width="60%" />                <br/>                <font color="AAAAAA">在本图中，左图显示了白方可能采取的走法，将对手的三个棋子括起来，形成右图所示的位置。</font>            </center>        </td>    </tr></table><p>当且仅当一名玩家无法移动而其对手可以移动时，该玩家就错过了一个回合。 当两个玩家都无法移动时游戏结束。（这种情况通常（但并非总是）发生，因为所有方格都已被占据。）获胜者是棋盘上自己颜色的棋子数量较多的玩家； 如果没有这样的玩家，则结果为平局。</p><hr><h3 id="类文件，配置具体介绍"><a href="#类文件，配置具体介绍" class="headerlink" title="类文件，配置具体介绍"></a>类文件，配置具体介绍</h3><h4 id="玩家端（人类）"><a href="#玩家端（人类）" class="headerlink" title="玩家端（人类）"></a>玩家端（人类）</h4><ul><li>主要的游戏逻辑是在 BoardState 中。</li><li>数字代表颜色（1表示白色；-1表示黑色，0代表没有）</li><li>getContents(int x, int y)  和  void setContents(int x, int y, int piece)    允许在棋盘方块上检索和设置。</li><li>boolean checkLegalMove(int x, int y),  它检查当前玩家是否有可能在正方形（x，y）上移动。</li><li>检索当前玩家的合法移动列表的方法是ArrayList<Move> getLegalMoves()。此方法返回当前玩家的所有合法移动。</li><li></li></ul><hr><h4 id="机器端（电脑）"><a href="#机器端（电脑）" class="headerlink" title="机器端（电脑）"></a>机器端（电脑）</h4><ul><li><p>计算机端（电脑）位于MoveChooser.java 中，其中的 <code>main</code> 程序创建了一个实例。</p></li><li><p>这个类所做的唯一的事情是实现静态方法 <code>chooseMove(BoardState boardState)</code> 在它的当前版本中，这个方法只是获取合法的移动，如果该列表为空，则返回null（记住我说的有时会没有合法的移动），否则返回该列表中的第一个移动。</p></li><li><p>在这里我们写一个更好的移动选择函数，而不是每次仅默认选择第一个。我们使用minimax with αβ-pruning 方法来优化。</p><ul><li>首先赋予棋盘每个位置相应的权重，为后续通过计算路线成本来规划最佳路线做准备。<br>&gt; 这些数字反映了一个玩家在各自的方块上的价值。请注意，边缘上的正方形具有很高的值（因为这里的块很难取），而角落上的正方形具有更高的值（因为这里不能取块）。相比之下，相邻的方块有负值，因为这里的一块将允许对手移动到一个高值的方块上。然后，板位置的值可以通过将白块占据的所有方块的权重加起来，然后减去黑块占据的所有方块的权重来定义。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// numbers reflect the value for a player of being on the respective square</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> positionValue[][] = &#123;   </span><br><span class="line">    &#123;<span class="number">120</span>, -<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">20</span>, -<span class="number">20</span>, <span class="number">120</span>&#125;,</span><br><span class="line">    &#123;-<span class="number">20</span>, -<span class="number">40</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">40</span>, -<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">20</span>, -<span class="number">5</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">15</span>, -<span class="number">5</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, -<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">20</span>, -<span class="number">5</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">15</span>, -<span class="number">5</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;-<span class="number">20</span>, -<span class="number">40</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">5</span>, -<span class="number">40</span>, -<span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">120</span>, -<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">20</span>, -<span class="number">20</span>, <span class="number">120</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>接下来是常规初始化：返回一个包含合法移动的列表，是否有合法移动可用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Move <span class="title function_">chooseMove</span><span class="params">(BoardState boardState)</span>&#123;</span><br><span class="line">      ArrayList&lt;Move&gt; moves = boardState.getLegalMoves();</span><br><span class="line">      <span class="keyword">if</span>(moves.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">return</span> topLevel(boardState, moves);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>下面是游戏🎮的分值计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/////////////////////////////////////////////////  write a better move selection function ///////////////////////////////////////</span></span><br><span class="line"><span class="comment">// board position = + weights of all those squares occupied by white pieces - weights of those squares occupied by black pieces.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">staticEvaluation</span><span class="params">(BoardState boardState)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123;</span><br><span class="line">            <span class="comment">// white</span></span><br><span class="line"><span class="keyword">if</span>(boardState.getContents(i, j)== <span class="number">1</span>)&#123;</span><br><span class="line">weight += positionValue[i][j]; </span><br><span class="line">            <span class="comment">// black</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(boardState.getContents(i,j)== -<span class="number">1</span>)&#123;</span><br><span class="line">weight -= positionValue[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> weight;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>使用MiniMax算法进行游戏博弈的静态方法。它接受一个BoardState对象作为游戏状态，一个搜索深度searchDepth，以及alpha、beta和maximizingNode作为MiniMax算法的参数，并返回一个整数值。</p><ul><li><p>首先，代码获取当前游戏状态下的合法移动，存储在move列表中。</p></li><li><p>接下来，代码根据不同的条件进行分支处理：</p><p> 如果searchDepth为0，即达到了搜索的最大深度，代码将调用staticEvaluation(boardState)方法对当前游戏状态进行静态评估，并返回评估值。<br> 如果maximizingNode为真，表示当前节点为最大化节点（轮到最大化玩家走子），代码将执行Max节点的逻辑。<br> 如果以上条件都不满足，表示当前节点为最小化节点（轮到最小化玩家走子），代码将执行Min节点的逻辑。</p></li><li><p>Max节点的逻辑：</p><p>  将alpha初始化为最小整数值，表示下界。<br>  对于每个合法移动，进行以下操作：  </p><ul><li>如果alpha &gt;&#x3D; beta，即上界小于等于下界，或者move列表为空，退出循环。  </li><li>创建一个boardState对象的深拷贝，用于模拟在当前移动下的新游戏状态。  </li><li>对深拷贝的boardState对象调用makeLegalMove(move.get(i).x, move.get(i).y)方法，执行当前移动。  </li><li>调用miniMax(boardState1, searchDepth-1, alpha, beta, false)方法，以递归方式搜索下一层的最小化节点，并将返回值存储在miniVal中。<br>  如果miniVal大于alpha，更新alpha的值为miniVal。<br>  返回alpha作为当前节点的评估值。</li></ul></li><li><p>Min节点的逻辑：</p><p>  将beta初始化为最大整数值，表示上界。<br>  对于每个合法移动，进行以下操作：  </p><ul><li>如果alpha &gt;&#x3D; beta，即上界小于等于下界，或者move列表为空，退出循环。  </li><li>创建一个boardState对象的深拷贝，用于模拟在当前移动下的新游戏状态。  </li><li>对深拷贝的boardState对象调用makeLegalMove(move.get(i).x, move.get(i).y)方法，执行当前移动。  </li><li>调用miniMax(boardState1, searchDepth-1, alpha, beta, true)方法，以递归方式搜索下一层的最大化节点，并将返回值存储在maxVal中。<br>  如果maxVal小于beta，更新beta的值为maxVal。<br>  返回beta作为当前节点的评估值。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// αβ-pruning DFS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">miniMax</span><span class="params">(BoardState boardState, <span class="type">int</span> searchDepth, <span class="type">int</span> alpha, <span class="type">int</span> beta, Boolean maxmizingNode)</span>&#123;</span><br><span class="line">ArrayList&lt;Move&gt; move = boardState.getLegalMoves();</span><br><span class="line"><span class="keyword">if</span>(searchDept == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> staticEvaluation(boardState);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxmizingNode)&#123;</span><br><span class="line">        alpha = Integer.MIN_VALUE;  <span class="comment">// lower bound</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;move.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(alpha &gt;= beta || move.isEmpty())&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// a fresh copy of boardState</span></span><br><span class="line"><span class="type">BoardState</span> <span class="variable">boardState1</span> <span class="operator">=</span> boardState.deepCopy();</span><br><span class="line">boardState1.makeLegalMove(move.get(i).x, move.get(i).y);</span><br><span class="line"><span class="type">int</span> <span class="variable">miniVal</span> <span class="operator">=</span> miniMax(boardState1, searchDepth-<span class="number">1</span>, alpha, beta, <span class="literal">false</span>);<span class="comment">// next is minimizing</span></span><br><span class="line"><span class="keyword">if</span>(alpha &lt; miniVal)&#123;<span class="comment">// update alpha</span></span><br><span class="line">alpha = miniVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> alpha;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">beta = Integer.MAX_VALUE;   <span class="comment">// upper bound</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;move.size(); i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(alpha &gt;= beta||move.isEmpty())&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// a fresh copy of boardState</span></span><br><span class="line"><span class="type">BoardState</span> <span class="variable">boardState1</span> <span class="operator">=</span> boardState.deepCopy();</span><br><span class="line">boardState1.makeLegalMove(move.get(i).x, move.get(i).y);</span><br><span class="line"><span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> miniMax(boardState1, searchDepth-<span class="number">1</span>, alpha, beta, <span class="literal">true</span>);<span class="comment">// next is maxmizing</span></span><br><span class="line"><span class="keyword">if</span>(maxVal &lt; beta)&#123;<span class="comment">// update beta</span></span><br><span class="line">beta = maxVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> beta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顶层调用与后续调用略有不同，因为您必须选择产生最佳子节点的着法（从计算机玩家的角度来看），而不是简单地评估子节点的值。 重要的是，当且仅当没有可用的移动时，程序才返回空移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// The top-level call</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Move <span class="title function_">topLevel</span><span class="params">(BoardState bs, ArrayList&lt;Move&gt; move)</span>&#123;</span><br><span class="line"><span class="comment">// searchDepth 设置成8保证运行速度和智能程度的权衡</span></span><br><span class="line">   <span class="type">int</span> searchDepth= Othello.searchDepth;</span><br><span class="line">   <span class="type">int</span> <span class="variable">valueIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.MIN_VALUE;<span class="comment">// negative infinity</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">// positive infinity</span></span><br><span class="line">   <span class="type">Move</span> <span class="variable">bestChoice</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// set when there are no moves available as the default value </span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;move.size(); i++)&#123;</span><br><span class="line">   <span class="type">BoardState</span> <span class="variable">temp</span> <span class="operator">=</span> bs.deepCopy();</span><br><span class="line">   temp.makeLegalMove(move.get(i).x, move.get(i).y);</span><br><span class="line">   <span class="type">int</span> <span class="variable">minimax</span> <span class="operator">=</span> miniMax(temp, searchDepth-<span class="number">1</span>, a, b, <span class="literal">false</span>);<span class="comment">// at the beginning set to minimizing node</span></span><br><span class="line">   <span class="keyword">if</span>(a&lt;minimax)&#123;</span><br><span class="line">   a=minimax;</span><br><span class="line">   valueIndex = i;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   bestChoice = move.get(valueIndex);</span><br><span class="line">   <span class="keyword">return</span> bestChoice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="游戏运行注意事项"><a href="#游戏运行注意事项" class="headerlink" title="游戏运行注意事项"></a>游戏运行注意事项</h2><ul><li>当且仅当一个玩家不能移动，但TA的对手可以移动时，TA才算错过这个回合。 </li><li>人类玩家（总是黑色）与计算机（总是白色）颜色保持不变。   </li><li>点击不合法动作的方块会产生警告声；如果轮到玩家（人类）下棋，但玩家没有合法的移动 ，那么玩家必须点击棋盘上的任何地方以允许游戏传递到电脑；  </li><li>如果玩家想玩另一个游戏，需要关闭窗口，重新运行程序。  </li><li>最好在电脑“思考”时不要点击以进行干扰。  </li><li>最后，作为一种特别的刺激，如果游戏以电脑的移动而结束，那么玩家必须点击棋盘才能看到结果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过函数式编程和四叉树模型解决双值图像的色彩处理问题 Using Haskell to solve QuadTree problems</title>
      <link href="/2023/06/24/Use-Haskell-solve-QuadTree-problems/"/>
      <url>/2023/06/24/Use-Haskell-solve-QuadTree-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="通过函数式编程和四叉树模型解决双值图像的色彩处理问题"><a href="#通过函数式编程和四叉树模型解决双值图像的色彩处理问题" class="headerlink" title="通过函数式编程和四叉树模型解决双值图像的色彩处理问题"></a>通过函数式编程和四叉树模型解决双值图像的色彩处理问题</h1><!--  --><h2 id="二叉树的介绍"><a href="#二叉树的介绍" class="headerlink" title="二叉树的介绍"></a>二叉树的介绍</h2><p>四叉树（Quad Tree）是一种树状数据结构，可用于表示图像。在每一个四叉树会有四个子区块。四叉树常应用于二维空间资料的分析与分类。 它将资料区分成为四个象限。资料范围可以是方形或矩形或其他任意形状。这种数据结构是由 拉斐尔·芬科尔(Raphael Finkel) 与 J. L. Bentley 在1974年发展出来。 类似的资料分割方法也称为 Q-tree。</p><p>本博文中使用函数式编程(Functional Programming)的Haskell作为编程语言，通过递归思想，实现对由四叉树表示的的双值图像的色彩检测。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>假设我们需要存储一张像素大小为 2^{𝑛} ∗ 2^{𝑛} 的正方形双值（黑白双色）图像，一般使用一个bit（0或1）来存储一个像素值，需要2^{𝑛} ∗ 2^{𝑛} bit的存储空间。但如果图像中有大面积的单色区域，这种存储方式可能会造成浪费。</p><!-- ![原图像](/img/Haskell01.png)![右下角浪费](/img/Haskell02.png)![左上角也浪费](/img/Haskell03.png) --><table rules="none" align="center">    <tr>        <td>            <center>                <img src="/img/Haskell01.png" width="60%" />                <br/>                <font color="AAAAAA">原图像</font>            </center>        </td>        <td>            <center>                <img src="/img/Haskell02.png" width="60%" />                <br/>                <font color="AAAAAA">右下角浪费</font>            </center>        </td>        <td>            <center>                <img src="/img/Haskell03.png" width="60%" />                <br/>                <font color="AAAAAA">左上角的四分格中也浪费</font>            </center>        </td>    </tr></table><h2 id="解决方案大致思想"><a href="#解决方案大致思想" class="headerlink" title="解决方案大致思想"></a>解决方案大致思想</h2><p>在这种情况下，一个简单的优化方式是将图像分为四个大小为 2^{𝑛-1} ∗ 2^{𝑛-1} 的子图像，我们将其称为“象限”（quadrants）。 如果某子图像是纯色图像，我们可以用单一颜色信息（黑色或白色）来表示。但如果它包含不同的颜色（黑色和白色混掺），我们可以再次细分，并继续递归，直到我们得到只有一种颜色的子图像。（此方案理论上可行：如果我们不断递归直至子图像缩小到原始像素的比例，问题一定能解决）。 我们将最终数据结构中的这些单一颜色子图像称为“单元”（Cell）。现实中，我们还要考虑图像实际大小，色彩标准，像素维度等多重复杂因素，在此我们忽略。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>首先定义几种Algebraic Data Type，也就是用关键词data来定义的代数数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 初始化颜色（黑与白） initialise colors&#x27; data type </span><br><span class="line">data Color = Black | White deriving (Eq, Show)</span><br></pre></td></tr></table></figure><p>这里把子图像定义为四叉树，纯色图像（Cell）和混色图像（Grid）都是子图像的子集，其中混色图像可以继续细分，直至变成纯色图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 实现四叉树（遵循数学中象限的定义方式：右上角为第一象限，逆时针递进，右下角为第四象限） implement QuadTree (the order of quadrant follows mathematical coordinate system)</span><br><span class="line">data QuadTree = Cell Color Int | Grid QuadTree QuadTree QuadTree QuadTree deriving (Eq, Show)</span><br></pre></td></tr></table></figure><p>一个函数 allBlack，它接受一个整数 n 并返回一个全黑的单个细胞的表示。 参数 n 代表图像“大小”，但由于任何尺寸的全黑图像看起来都相同，因此可以忽略此参数！ 但是我没有忽略！！！（后续有用…）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- returns a Black or White cell of a specified size</span><br><span class="line">allBlack :: Int -&gt; QuadTree</span><br><span class="line">allBlack size = Cell Black size</span><br></pre></td></tr></table></figure><p>一个函数 allWhite，它接受一个整数 n 并返回一个全白的单个细胞的表示。 参数 n 代表图像“大小”，同上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allWhite :: Int -&gt; QuadTree</span><br><span class="line">allWhite size = Cell White size</span><br></pre></td></tr></table></figure><p>一个顺时针函数，它采用四个四叉树并返回四叉树，其四个子树是给定输入，按顺时针顺序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- The first quadrant is top-right!</span><br><span class="line">clockwise :: QuadTree -&gt; QuadTree -&gt; QuadTree -&gt; QuadTree -&gt; QuadTree</span><br><span class="line">clockwise a b c d = Grid a b c d</span><br></pre></td></tr></table></figure><p>一个逆时针函数，它采用四个四叉树并返回四叉树，其四个子树是给定输入，按逆时针顺序排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anticlockwise :: QuadTree -&gt; QuadTree -&gt; QuadTree -&gt; QuadTree -&gt; QuadTree</span><br><span class="line">anticlockwise a b c d = Grid a d c b</span><br></pre></td></tr></table></figure><p>顺时针排序是指在a b c d顺时针方向的四叉树中，子树b位于a顺时针移动到达的象限内，c位于b顺时针移动到达的象限内，d位于c顺时针移动到达的象限内，a位于从d顺时针移动到达的象限内。反之亦然。</p><h2 id="重头戏"><a href="#重头戏" class="headerlink" title="重头戏"></a>重头戏</h2><p>接下来我们要进行图像处理，定义一个函数：reverse，它将四叉树作为输入并返回一个新的四叉树作为输出。 此函数不应该改变quadtree的结构，但应该改变里面表示黑白颜色的数据内容。<br>改变规则如下：<br><strong>当且仅当超过一半的邻边或部分边（这里统称为“邻居”）的单元颜色与此单元自身颜色不一致时，反转此单元的颜色（假设该单元格原先为黑色的话，现在变为白色）。</strong><br>例如，如果一个单元在输入q中是黑色的，那么它在输出模糊q中应该是白色的，当且仅当在q中它的邻居中白色的单元多于黑色的单元。<br>此处注意，宏观来看一个完整图像的边界处的单元通常具有较少的邻居。<br><img src="/img/Haskell04.png" alt="效果1"><br><img src="/img/Haskell05.png" alt="效果2"></p><h1 id="以下思路从宏观到微观依次介绍，目的是为了增强思维连续性，便于读者理解"><a href="#以下思路从宏观到微观依次介绍，目的是为了增强思维连续性，便于读者理解" class="headerlink" title="以下思路从宏观到微观依次介绍，目的是为了增强思维连续性，便于读者理解"></a>以下思路从<strong>宏观</strong>到<strong>微观</strong>依次介绍，目的是为了增强思维连续性，便于读者理解</h1><h2 id="思路介绍："><a href="#思路介绍：" class="headerlink" title="思路介绍："></a>思路介绍：</h2><p>完成这个任务有几点要考虑：<br>1 必须确保图像中的每一个单元都遍历到，才能完全输出最终反转后的图像，不能有遗漏，进一步来讲需要知道哪些单元已经遍历过了，哪些还没到访过。<br>2 遍历的出发点选在哪？何时结束遍历？<br>3 遍历的路线是怎样的？</p><p>出发点设在整个图像的中心，中心也就是整个图像长度、宽度的各二分之一处（也就是中点，一半的意思），这样就构成了一个坐标系，由此开始递归遍历。<br>以下是整个程序的start point：启动整个程序，该函数输入一个四叉树，输出处理后的二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- Original Engine of whole programme</span><br><span class="line">-- use reverseMini to implement the tree</span><br><span class="line">reverse :: QuadTree -&gt; QuadTree</span><br><span class="line">reverse fullTree = reverseMini fullTree (fullTree, fullSize) (fullSize / 2, fullSize / 2, fullSize)</span><br><span class="line">  where fullSize = getWholeSize fullTree</span><br></pre></td></tr></table></figure><p>接下来接棒给另一个函数：reverseMini，该函数有好多个输入参数，依次是：<br>当前所在的四叉树，表示完整图像的四叉树，完成图像四叉树的大小，遍历过程中目前所在的点的坐标（x和y），当前所在四叉树的大小。<br>输出的四叉树就是返回给reverse的最终答案，以下是细节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- According to neighbor&#x27;s weight to decide if it should reverse the color</span><br><span class="line">-- Current QuadTree -&gt; (initial QuadTree, initial QuadTree size) -&gt; (Current x, y, Current QuadTree size) -&gt; output</span><br><span class="line">reverseMini :: QuadTree -&gt; (QuadTree, Double) -&gt; (Double, Double, Double) -&gt; QuadTree</span><br><span class="line">-- for Cell</span><br><span class="line">reverseMini (Cell ce cellSize) (fullTree, treeSize) (x_now, y_now, _)</span><br><span class="line">  --  more than half of its neighbours have the opposite colour, reverse its colour</span><br><span class="line">  | ce == Black &amp;&amp; (neighborWeight &gt; 0) = Cell White cellSize</span><br><span class="line">  | ce == White &amp;&amp; (neighborWeight &lt; 0) = Cell Black cellSize</span><br><span class="line">  | otherwise = Cell ce cellSize</span><br><span class="line">  where</span><br><span class="line">    neighborWeight = getNeighbourWeight (fullTree, treeSize) (x_now, y_now, fromIntegral cellSize)</span><br><span class="line">-- for Grid, contiinue recursion</span><br><span class="line">reverseMini (Grid a b c d) (fullTree, treeSize) (x_now, y_now, fullSize) =</span><br><span class="line">  clockwise</span><br><span class="line">    (reverseMini a (fullTree, treeSize) (x_now + offset, y_now - offset, fullSize / 2))</span><br><span class="line">    (reverseMini b (fullTree, treeSize) (x_now - offset, y_now - offset, fullSize / 2))</span><br><span class="line">    (reverseMini c (fullTree, treeSize) (x_now - offset, y_now + offset, fullSize / 2))</span><br><span class="line">    (reverseMini d (fullTree, treeSize) (x_now + offset, y_now + offset, fullSize / 2))</span><br><span class="line">  where</span><br><span class="line">    offset = fullSize / 4</span><br></pre></td></tr></table></figure><p>因为输入的四叉树可能是Grid也可能是Cell，在此分类讨论：</p><ul><li>若输入的是Cell，那么直接判断当前颜色是否与权重匹配，匹配则Cell颜色保持不变，若不匹配则颜色反转。“匹配”的含义后面会讲。</li><li>若输入的是Grid，则进一步递归当前四叉树的四个子图像a,b,c,d，同时自身坐标将会发生改变，迁移到下一个子图像的中心，用当前所在四叉树的大小折半来表示子图像的大小（四个子图像大小相等）。</li></ul><p>首先讲一下Cell部分的设计，这里设计了一个方法来判断是否有超过一半的邻居与自身颜色不同，此方法把黑色赋权为整数-1，白色赋权为+1。然后通过计算邻居的权重之和的正负来决定是否与之匹配。<br>在这里把<strong>自身颜色为白色且权重和为正数，或者自身颜色为黑色且权重和为负数</strong>都称作与之相匹配。</p><p>接下来介绍如何通过函数getNeighbourWeight来计算邻居的权重之和。<br>下面依次介绍输入参数：<br>表示完整图像的四叉树（原图像），完整图像四叉树的大小，邻居单元的x坐标和y坐标，邻居单元的规格；<br>输出的是当前邻居的权重之和。<br>这里因为递归路线的性质需要逆向探测，所以getNeighbour方向和border方向相反，也是最巧妙的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- get neighbors weight and sum the total weight of a cell&#x27;s all neighbors</span><br><span class="line">-- (initial QuadTree, initial QuadTree size) -&gt; (Neighbor Cell&#x27;s X coordinate, Cell&#x27;s Y coordinate, Cell&#x27;s size) -&gt; output</span><br><span class="line">getNeighbourWeight :: (QuadTree, Double) -&gt; (Double, Double, Double) -&gt; Int</span><br><span class="line">getNeighbourWeight (fullTree, treeSize) (x_cell, y_cell, cellSize) =</span><br><span class="line">      border (getNeighbour &quot;up&quot; (fullTree, treeSize) (x_cell, y_cell, cellSize)) &quot;down&quot;</span><br><span class="line">    + border (getNeighbour &quot;down&quot; (fullTree, treeSize) (x_cell, y_cell, cellSize)) &quot;up&quot;</span><br><span class="line">    + border (getNeighbour &quot;left&quot; (fullTree, treeSize) (x_cell, y_cell, cellSize)) &quot;right&quot;</span><br><span class="line">    + border (getNeighbour &quot;right&quot; (fullTree, treeSize) (x_cell, y_cell, cellSize)) &quot;left&quot;</span><br></pre></td></tr></table></figure><p> 此函数还需借鉴另外两个函数：getNeighbour和border。<br> 先介绍border函数，其输入参数为：<br> 当下需要遍历的四叉树（也可以不输入，此情况输出值为0），探测方向，<br> 输出的是根据单个Cell颜色得出的权重<br> border是“落实到基层”的函数，承担了真正根据Cell颜色赋予其权重的任务：白色+1，黑色-1，如果不是最小Cell（是Grid）就继续上下左右递归直到找到相应的Cell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- detect one specified border of a certain Gird/Cell and sum its all cells values(weights) according to colors</span><br><span class="line">-- a Quadtree (or Nothing) -&gt; one of the four inner-borders -&gt;</span><br><span class="line">border :: Maybe QuadTree -&gt; String -&gt; Int</span><br><span class="line">-- invalid</span><br><span class="line">border Nothing _ = 0</span><br><span class="line">-- calculate the weight of the Cell</span><br><span class="line">border (Just (Cell ce _)) _</span><br><span class="line">  | ce == White = 1 -- White cells are worth +1</span><br><span class="line">  | ce == Black = -1 -- black cells are worth -1</span><br><span class="line">--  continue to implement recursion for Grid if cell is not arrived</span><br><span class="line">border (Just (Grid a b c d)) direction</span><br><span class="line">  | direction == &quot;up&quot; = border (Just a) &quot;up&quot; + border (Just b) &quot;up&quot;</span><br><span class="line">  | direction == &quot;left&quot; = border (Just b) &quot;left&quot; + border (Just c) &quot;left&quot;</span><br><span class="line">  | direction == &quot;down&quot; = border (Just c) &quot;down&quot; + border (Just d) &quot;down&quot;</span><br><span class="line">  | direction == &quot;right&quot; = border (Just a) &quot;right&quot; + border (Just d) &quot;right&quot;</span><br></pre></td></tr></table></figure><p>接下来说getNeighbour，由于该函数大量调用了getGrid，因此我们需要先了解getGrid函数。<br>getGrid函数作为getNeighbour的辅助函数，是程序中最复杂的一个函数，它根据getNeighbour提供的坐标变化来进一步遍历。<br>输入参数介绍：<br>四叉树，四叉树的大小（起初是完整图像，后续是便利目标的子图像），当前所在点的X，Y坐标，当前所处四叉树的大小，目标四叉树（即将要遍历的）的中点坐标以及大小</p><p>该函数有几点功能：<br>检测当前所处Grid是否为边界Grid，若遇到边界则停止遍历，否则决定下一步遍历的移动方向。<br>这里的边界线探测还是用坐标的数值来推理得出，把最小的cell大小假设成1，判断过程可以理解为尝试性地迈出0.5步，如果迈出后的坐标大于临界点（即完整图像边框线）时，则停止移动。<br>若还可以继续移动，则需要给出下一个到访的cell的中心坐标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- helper function for getNeigbor: according to inputed coordinates and inputed size returns the Grid and also detect the boundary.</span><br><span class="line">-- Quadtree -&gt; its size -&gt; (current X coordinate, Y coordinate, size) -&gt; (target&#x27;s X coordinate, Y coordinate, size) -&gt;</span><br><span class="line">getGrid :: QuadTree -&gt; Double -&gt; (Double, Double, Double) -&gt; (Double, Double, Double) -&gt; Maybe QuadTree</span><br><span class="line">getGrid (Cell ce cellSize) _ _ _ = Just (Cell ce cellSize)</span><br><span class="line">getGrid (Grid a b c d) treeSize (x_now, y_now, sizeNow) (grid_x, grid_y, grid_size)</span><br><span class="line">  -- detect boundary</span><br><span class="line">  -- if it is already near the border, stop moving!</span><br><span class="line">  | grid_x &lt; 0.0 || grid_x &gt; (treeSize - 0.5) || grid_y &lt; 0.0 || grid_y &gt; (treeSize - 0.5) = Nothing</span><br><span class="line">  | sizeNow == grid_size = Just (Grid a b c d)</span><br><span class="line">  | x_now &gt; grid_x &amp;&amp; y_now &gt; grid_y = getGrid b treeSize (x_now - offset, y_now - offset, sizeNow / 2) (grid_x, grid_y, grid_size)</span><br><span class="line">  | x_now &lt; grid_x &amp;&amp; y_now &gt; grid_y = getGrid a treeSize (x_now + offset, y_now - offset, sizeNow / 2) (grid_x, grid_y, grid_size)</span><br><span class="line">  | x_now &gt; grid_x &amp;&amp; y_now &lt; grid_y = getGrid c treeSize (x_now - offset, y_now + offset, sizeNow / 2) (grid_x, grid_y, grid_size)</span><br><span class="line">  | x_now &lt; grid_x &amp;&amp; y_now &lt; grid_y = getGrid d treeSize (x_now + offset, y_now + offset, sizeNow / 2) (grid_x, grid_y, grid_size)</span><br><span class="line">  -- offset means how far the coordinate system should move</span><br><span class="line">  where</span><br><span class="line">    offset = sizeNow / 4</span><br></pre></td></tr></table></figure><p>最后我们介绍一下getNeighbor，输入参数为：<br>移动方向（进一步传导给getGrid），表示完整图像的四叉树，完成图像四叉树的大小，目标点的X，Y坐标和大小。<br>其主要作用是如何递归地调用getGrid，巧妙决定移动方向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">--  returns the Quadtree representing one of his four direct neighbors (top, bottom, left, right)</span><br><span class="line">-- direction -&gt; (initial QuadTree, initial QuadTree size) -&gt; (Cell&#x27;s X coordinate, Cell&#x27;s Y coordinate, Cell&#x27;s size)</span><br><span class="line">getNeighbor :: String -&gt; (QuadTree, Double) -&gt; (Double, Double, Double) -&gt; Maybe QuadTree</span><br><span class="line">getNeighbor direction (fullTree, treeSize) (x_cell, y_cell, cellSize)</span><br><span class="line">  | direction == &quot;top&quot; = getGrid fullTree treeSize (tree_center, tree_center, treeSize) (x_cell, y_cell - cellSize, cellSize) -- top</span><br><span class="line">  | direction == &quot;bottom&quot; = getGrid fullTree treeSize (tree_center, tree_center, treeSize) (x_cell, y_cell + cellSize, cellSize) -- bottom</span><br><span class="line">  | direction == &quot;left&quot; = getGrid fullTree treeSize (tree_center, tree_center, treeSize) (x_cell - cellSize, y_cell, cellSize) -- left</span><br><span class="line">  | direction == &quot;right&quot; = getGrid fullTree treeSize (tree_center, tree_center, treeSize) (x_cell + cellSize, y_cell, cellSize) -- right</span><br><span class="line">  where</span><br><span class="line">    tree_center = treeSize / 2</span><br></pre></td></tr></table></figure><p>下面补充两个辅助函数，第一个用来计算某个四叉树的大小，第二个用来作为颜色的中间转换函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- output the size of a QuadTree by calculating the length of one side (eg. top)</span><br><span class="line">getTreeSize :: QuadTree -&gt; Double</span><br><span class="line">getTreeSize (Cell ce size) = fromIntegral size</span><br><span class="line">getTreeSize (Grid a b c d) = getTreeSize a + getTreeSize b</span><br><span class="line"></span><br><span class="line">-- detect one specified side of a certain Gird/Cell and sum its all cells values according to colors</span><br><span class="line">-- a Quadtree (or Nothing) -&gt; one of the four inside-borders -&gt;</span><br><span class="line">side :: Maybe QuadTree -&gt; String -&gt; Int</span><br><span class="line">-- invalid</span><br><span class="line">side Nothing _ = 0</span><br><span class="line">-- calculate the weight of the Cell</span><br><span class="line">side (Just (Cell ce _)) _</span><br><span class="line">  | ce == White = 1 -- White cells are worth +1</span><br><span class="line">  | ce == Black = -1 -- black cells are worth -1</span><br><span class="line">--  continue to implement recursion for Grid if cell is not arrived</span><br><span class="line">side (Just (Grid a b c d)) direction</span><br><span class="line">  | direction == &quot;top&quot; = side (Just a) &quot;top&quot; + (side (Just b) &quot;top&quot;)</span><br><span class="line">  | direction == &quot;bottom&quot; = side (Just c) &quot;bottom&quot; + (side (Just d) &quot;bottom&quot;)</span><br><span class="line">  | direction == &quot;left&quot; = side (Just b) &quot;left&quot; + (side (Just c) &quot;left&quot;)</span><br><span class="line">  | direction == &quot;right&quot; = side (Just a) &quot;right&quot; + (side (Just d) &quot;right&quot;)</span><br></pre></td></tr></table></figure><p>至此，完整的代码已全部展现。</p>]]></content>
      
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
            <tag> Functional Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/02/25/hello-world/"/>
      <url>/2023/02/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
